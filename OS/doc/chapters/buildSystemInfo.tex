\begin{verbatim}

Well, Stefan would know better, but as I understand it, the
AC_COIN_HAS_PACKAGE command actually first creates *_LIB and *_CFLAGS
variables for the package named in the first argument and then also
adds those to the *_LIB and *_CFLAGS variables of the library/binary
that depends on the package being defined. So the COINDEPEND_CFLAGS
are just the combination of the flags of the individual packages that
make up CoinDepend. These then get added to XXXLIB_CFLAGS along with
any other dependent project identified in later AC_COIN_HAS_PACKAGE to
form the full set of flags for XXXLIB. Admittedly, this is a bit
confusing and I'm not sure I got it entirely right. Stefan?



This has nothing to do with how you code as a developer. We are
talking about users, not you, when we talk about what should be in the
Makefile for the examples. To a user, all they have to know is that
they want to link to OS. A user should not have to know that, for
instance, you built without support for Bonmin and Couenne this time
because they aren't available and so they don't have to put those on
the link line. How would they know that? The .pc file automatically
contains whatever dependencies were present at the time of the
building of the library, no matter what those were. As far as
development goes, nothing changes in the above.

> 2.  OS depends, for example, on Cgl. But OS also uses SYMPHONY. In SYMPHONY
> you have
>
> Requires: cgl osi-vol osi-dylp osi-clp coinutils = trunk osi
>
> so should I skip Cgl?

If it is possible for OS to use Cgl *directly*, not *indirectly*
because some other project linked to by OS needs it, then it should be
listed. But I don't really see how you could use Cgl directly without
having some project like Cbc, SYMPHONY, Bonmin, Couenne, etc. present,
in which case Cgl would be among the dependencies of *that* project.
Is there a use case where you would want to link to Cgl without one of
the others present?

In any case, this is not something you have to decide since these
dependencies are generated automatically based on what projects you
check for in configure.ac. The checking there works the same way---you
only check for the things that you directly depend on, not the
secondary dependencies. the m4 macros use pkg-config in the same way
as I've been describing to generate the secondary dependencies. So
just don't worry about what goes in the .pc files under
dependencies---it's checks in configure.ac that you have to worry
about. Just eliminate any that you don't need (such as for Cgl?) and
they will not appear in the .pc file either.

> Maybe not if the user has not installed SYMPHONY.
>  Also, I see you have osi-clp, but NOT clp. I guess based on what you said
> about the recursive nature of things this is not necessary since osi-clp has
>
> Requires: clp osi

Yes, SYMPHONY can't use Clp except through Osi, so there is no reason
to check for Clp directly. If we had a native interface to Clp that
could be used if Osi was missing, then Clp could be checked for as a
dependency. 


From Lou:

> What happened to $(COINUTILSSRCDIR)????

	Answer on two levels. First, for the file you were looking at
(CoinUtils/test/Makefile.am), it makes sense to give a relative location
for the headers. If you're building in the test directory, the headers
are in ../src. If you're doing a VPATH build, you need to know where the
source directory is, then a relative path, hence $(srcdir)/../src. The
rule to remember is that srcdir is the source for the directory you're
building. When you're building the test directory, srcdir resolves to
the source for test.

	More generally, what happened to COINUTILSSRCDIR? A short but somewhat
misleading answer would be `It's been replaced by COINUTILS_CFLAGS'. But
a longer answer may give you a better perspective.

	It's been replaced by pkg-config, and a whole bunch of buildtools
macros that query pkg-config and deal with the situation when pkg-config
isn't available (I'll let Stefan speak to that). If you want to know the
header directories for CoinUtils, you ask

  pkg-config --cflags coinutils

and pkg-config consults coinutils.pc to give the answer (correct for my
particular configuration)

-I/devel/Coin/Split-FedGCC64/include/coin
-I/devel/Coin/Split-FedGCC64/include/coin/ThirdParty

These are the places to look for the installed headers for CoinUtils and
Glpk in my local build structure. Notice that pkg-config is helping me
here, keeping track of the fact that my CoinUtils build brings in glpk.
To get the libs needed to link against libCoinUtils,

  pkg-config --libs coinutils

gives

 -L/devel/Coin/Split-FedGCC64/lib/coin  
 -L/devel/Coin/Split-FedGCC64/lib/coin/ThirdParty -lCoinUtils -lbz2 
 -llapack -lblas -lm -lcoinglpk -ldl -lgmp -lz

So you can see why this simplifies things in the makefiles. When you're
building against uninstalled packages pkg-config needs to find
coinutils-uninstalled.pc. Again, the buildtools macros take care of
this, manipulating PKG_CONFIG_PATH so that pkg-config can find the
right .pc file.

You can ask for information about more than one package, e.g.,

  pkg-config --cflags coinutils osi cgl

and you'll get the combined information for all, duplicates removed:

  -I/devel/Coin/Split-FedGCC64/include/coin 
  -I/devel/Coin/Split-FedGCC64/include/coin/ThirdParty
  
If you're saying `but that's exactly the same as the previous answer',
you're exactly right. All the installed header files are in one place.
You don't get the same information repeated three times (for CoinUtils,
Osi, and Cgl). So when configure.ac uses

AC_COIN_HAS_PACKAGE(CoinDepend, [cgl osi coinutils = trunk], [CbcLib
CbcGeneric])

what will happen is that buildtools creates a variable,
COINDEPEND_CFLAGS, and this is set to the output of

  pkg-config --cflags cgl osi coinutils

(with some fussing to make sure it's the trunk of coinutils).
COINDEPEND_CFLAGS will be added to command lines when building CbcLib
and CbcGeneric.

	Hope this helps. There's nothing quite so frustrating as finding
yourself afloat in an unfamiliar sea.


%%%%%%%%%%%

export  PKG_CONFIG_PATH=/Users/kmartin/coin/os-tmp/vpath-debug/lib/pkgconfig 

%%%%%%

Here is something from Ted explaining how the Build System determines if something is a dependency


Well, here's the answer. The check in configure.ac looks like this:

AC_COIN_HAS_PACKAGE(ASL,   [coinasl])   <====== missing the third argument
AC_COIN_HAS_PACKAGE(HSL,   [coinhsl],   [IpoptLib])
AC_COIN_HAS_PACKAGE(Mumps, [coinmumps], [IpoptLib])

So ASL is not going to be listed as a dependency for the Ipopt
*library* and I guess that's because it isn't a dependency of the
*library*, just of the *binary*. Apparently, the AMPL interpreter is
not part of the library (unless this is a mistake). So you can link to
the Ipopt library without liniking to ASL. However, in the case of
ASL, that really is a direct dependency of OS, right? You can directly
read AMPL files, independent of any solver being able to solve
whatever you read in, right?


%%%%%%%%

Another hint from Lou:

	As Stefan says, += doesn't work in all shells. I'm probably telling you
something you know, but the standard idiom looks like this:

OSLIB_LIBS="$LIBS $OSLIB_LIBS"

to prepend. Reverse the order to append. I'm a serial offender on this;
I regularly forget that I need to add to a variable without trashing the
existing value.

						Lou
%%%%%%%%%%%%%%%%%

INFO on Externals

        You'll want to migrate towards Dependencies and the use of the
set_externals script to set svn:externals.  Documentation has definitely fallen
behind.  I guess what you're seeing here is bits of the new order --- the
independent (split) configuration stuff that Stefan's been implementing ---
starting to leak out.  I used the revised scripts described below to generate
the releases you were questioning.

        You can certainly keep on using the Externals file and
BuildTools/stable/0.6 for a while yet.  BuildTools/trunk should work on the
classic configuration with externals, so you should be able to use it on OS in
the classic packaging.  BuildTools/trunk is essential if you're going to
experiment with the split configuration (i.e., each project checked out
independently, without externals).

        There are major changes in the [prepare,commit]_new_[stable,release]
scripts in BuildTools/trunk.  (In fact, *_new_stable do not exist anywhere
except BuildTools/trunk.)  Also for run_autotools.  They are much more flexible
in terms of where they live and how they are run.  In the split configuration,
there's no guarantee that BuildTools will be present in the classic external
position.  The revised *_new_* scripts behave like normal command scripts.  You
can, for instance, copy them into some directory that's already in your command
search path and execute them from there.  Run_autotools is a bit more limited
due to its need for a number of autotools scripts that we distribute in
BuildTools. The revised scripts have long usage messages; they will help you.

        Prepare_new_stable will look to see whether you've supplied Externals or
Dependencies in your trunk.  If you've created Dependencies, it will use it.  If
all you have is Externals, it will generate Dependencies from Externals and add
it to the stable candidate.

        I'm not sure how much will be useful to you, but I've attached some
scripts below that I use to maintain a split configuration (trunks).  Create a
directory (e.g., Split) where you want the checkout to live.  Start with
getSplit, which will do checkout, update, or status.  When it finishes, you'll
have separate subdirectories for BuildTools, CoinUtils, Osi, etc.  If you want
to run the autotools, just type BuildTools/run_autotools in the Split directory.

        ConfigSplit will run configure, make, and make install (install is a
necessary step in a split configuration).  The first 2/3 of the script are of
marginal utility unless you adopt my stylised naming convention for build
directories. But the final third shows how to run make and make install.

	(Stylised naming convention: Suppose you checked out the split 
configuration in <path>/Split. The script expects the build directory to be
	named <path>/Split-<OS><compiler><bits><opt>
For example, Split-FedGCC64Opt is Fedora, GCC, 64-bit, optimised. Check the 
script to see what it recognises and adapt accordingly.)

	getThirdParty will haul down third-party software into the appropriate
ThirdParty subdirectories.

	testSplit will run `make test'
	
This is probably way more than you wanted to know on Saturday morning   :-)   But 
I'm on a flex week, today's a normal workday for me.
	
							Lou
%%% 


Stefan on LIBS

XXXLIB_LIBS is what you should use in your Makefile.am, XXXLIB_PCLIBS is
what you should use in the .pc.in file to setup the Libs entry.
The thing is that XXXLIB_LIBS hold all flags needed to link against
XXXLIB, but for the .pc file you want to distinguish between
dependencies that have a .pc file and those where you just know the
linking flags. So these two informations are stored in XXXLIB_PCREQUIRED
and XXXLIB_PCLIBS.


%%%%%%%%%%%%

Ralphs on naming convention

First of all, if it's working, then the names are correct  :) . Don't
overthink it  :) . The names are whatever *you* choose them to be for
your individual project. Whatever name you give to the corresponding
package in *your* configure.ac is how those variables get named. Since
you have the line

AC_COIN_CHECK_PACKAGE(Clp, [osi-clp]. [OSLib])

in your configure.ac, the variable for Clp libraries will be CLP_LIBS.
If you change the first argument of AC_COIN_CHECK_PACKAGE to "ClpLib,"
then you would use CLPLIB_LIBS. It doesn't matter what any other
project does. You choose your names within your project, though it
would probably be nice if we did it all similarly to avoid too much
confusion. At the moments, I believe we are mostly similar, but the
reason project add "LIB" onto the names internally is to distinguish
between dependencies for the library versus the executable. Since you
don't have to make that distinction (you are only using the library),
you don't need the redundant "LIB" added to the name.

Cheers,

From Stefan, December 5, 2010

The macro figures out all the compiler and linker flags necessary to
link to OsiClp and puts these into the variables CLP_CFLAGS and
CLP_LIBS. Further, it also adds them to OSLIB_CFLAGS and OSLIB_LIBS.
So the series of AC_COIN_CHECK_PACKAGE's in your configure.ac should
accumulate the compiler and linker flags for all dependencies of OS.

Form the X_LIBS variable, the macro creates then a X_DEPENDENCIES
variable, which is the same as X_LIBS, except that everything starting
with a '-' is removed. So i you had X_LIBS="libCoinUtils.la -lm", then
X_DEPENDENCIES will be just "libCoinUtils.la".

In the old system, this happened automatically. When automake saw
"libCoinUtils.la -lm" in an LDADD variable, then it created a
DEPENDENCIES variable which had only "libCoinUtils.la". However, in the
new system, we mostly list variables in LDADD (e.g., $(OSLIB_LIBS)), and
automake cannot convert this into a DEPENDENCIES variable (since at the
time automake is run, it does not know what $(OSLIB_LIBS) will later
be). So one has to set DEPENDENCIES by hand now.

To get the DEPENDENCIES working, a change in the xxx-uninstalled.pc file
is necessary. It needs to list the .la file with full path, not using
the -L/-l syntax . This change is only in trunk yet, so if you use
stable's in your externals, then, e.g., a rebuild of libClp does not
trigger automatically a rebuild of OS, yet.

> > It now seems that make 

%%%%%%%%%%%%%%%%
More on Externals -- I think I understand -- from around December 6 and 7 2010

Priority is what you see if you do
  svn propget svn:externals .

I think the new idea is that one don't have an Externals file anymore,
but only a Dependencies file. Usually, one lists all stable externals in
the Dependencies file and uses BuildTools/set_externals to set the
svn:externals property to the latest releases.
However, if one specifies trunk's in Dependencies, then set_externals
will also keep them as trunk's.

The svn:externals properties are part of the repository, so they are set
on the server. When svn does a checkout, it looks for the value of
svn:externals, and the checks out everything in there too.
The Externals or Dependencies file is just something COIN-OR specific. I
think the use of the Externals file is to make it easier to edit the
svn:externals property. I.e., you edit the file and then set the svn
property to the content of this file (svn propset svn:external . -F
Externals)

Here is the thing to do:


Okay, this really helps. So when things settle down, then I should:

1) trash the OS Externals file


2) set the Dependicies file to point to BuildTools stable.


3) run BuildTools/set_externals

4) do an svn commit

and that will then set the svn:externals properties on the server/repository. 

%%%%%%%%%%%
Stefan on examples

The only way that the examples work under cygwin/cl is if you disable
pkg-config. Examples with cygwin/cl/pkg-config does not work for any
project.
I also added documentation about the examples Makefile's at
https://projects.coin-or.org/BuildTools/wiki/pm-switch#RootXxxexamplesMakefile.in

Andreas noted to me today that the "ifeq" and "+=" that are used in the
examples makefiles now work only for GNU make  :-( . So for Ipopt we will
do something different,
https://projects.coin-or.org/Ipopt/browser/trunk/Ipopt/examples/Cpp_example/Makefile.in?rev=1875

Stefan

%%%%%%%%%%%%%%%%

Setting Externals the old way

Hmm, I haven't tried what happens if set_externals does not find a
release, maybe you just try  :-) .
Otherwise, I think just doing
  svn propset svn:externals -F Dependencies .
would be enough.



%%%%%%%%%%%%%%%%%%%%%%

March 18 Information from Lou

    Looks like Ted, Stefan, and I haven't been good enough at communicating how we're handling externals these days. See
https://projects.coin-or.org/BuildTools/wiki/pm-svn-releases
Here's a summary.

    First, you have the svn:externals property. This is what svn uses when checking out externals. So the question of interest is `How to set svn:externals?'

    Start with Dependencies. In trunk, it can be anything you like. When you run create_new_stable, a fresh copy of Dependencies is created and committed with the new stable. References to trunk externals are replaced with references to stable externals. References to release externals are unchanged. To set svn:externals on the new stable, the set_externals script is used; references to stable externals are converted to releases.

    When you execute prepare_new_release on a stable branch, Dependencies is processed to find the most recent releases for the stable externals, the result is used to set svn:externals, and the release is created. Dependencies still specifies stable branches, svn:externals specifies releases.

    The prepare_new_stable and prepare_new_release scripts have lots of options to affect these conversions. See the help message for the scripts. You can always use svn propset if the scripts are not doing what you want.

    The intended result is that in a stable or release, the Dependencies file should specify stable externals. Specify a particular release only if you absolutely must. The set_externals script processes Dependencies, finds the most recent release for each stable external, and uses that to set svn:externals. The important point is that Dependencies will typically specify other stables, but svn:externals will specify releases. This is a departure from the past, where the convention was that what you saw in Dependencies (and before that, Externals) was the same as svn:externals.

    Clear as mud?

                    Lou 


    When someone checks out OS/stable/2.3, they will get the set of externals that was frozen in svn:externals the last time that someone ran BuildTools/set_externals on the Dependencies file and committed the change to svn:externals. Dependencies doesn't change, only svn:externals, so it's kind of subtle. Once svn:externals is changed (locally or in the repository) the next svn update command will switch to the new externals.

    It's the responsibility of the project developers to run set_externals every so often to keep a stable up-to-date with respect to new releases. Generally this isn't a big issue.

    The problem with Osi (and any project that has an OsiXXX layer) is that there was a major rearrangement of the src directories between 0.103 and 0.104 (or thereabouts). All the OsiXXX code was moved out to project XXX, and the Osi src directory was reorganised. Then we got into a rush to push out a new CoinAll before INFORMS Austin. The net result is that the VS solution files in O.104.1 are wrong. They were not updated to reflect all the movement of source code. The VS solution files in 0.104.2 are correct. Similarly for Cbc (OsiCbc), Clp (OsiClp), DyLP (OsiDylp), Vol (OsiVol), and SYMPHONY (OsiSym). The OsiXXX source for thirdparty and commercial solvers remains in the Osi project.

    This was a clear screw-up on the part of Ted, Stefan, and I, and I can only plead time pressure. Ted and Stefan don't work with VS, and I work in trunk (unless someone complains and forces me to go look at a stable :-) . By the time this problem occurred to me, it was too late to do anything except resolve to fix it in the next release. We knew it was wrong as it was going out the door.

    For what it's worth, I don't agree with reducing stable externals to releases for a stable, but I seem to be in the minority. I use trunk externals in trunk and would prefer using stable externals in stable, to avoid just this sort of problem. I figure anyone who uses a stable can probably cope with the stream of changes coming over from trunk. But I've never been successful in arguing this when the topic comes up in the TLC.

                        Lou

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Added 5-Sep-2017: stuff about various configeration files

From gus: Files used in configuring the OS code

BuildTools/headers/configall_system.h
    used when there is no configure script 
    includes configall_system_msc.h for windows systems
    throws an error otherwise but could be extended for esoteric system
    included in all project-specific files xxx/config_default.h, e.g., OS/src/config_default.h

BuildTools/headers/configall_system_msc.h
    sets windows-specific values (including Fortran compiler, etc.) system and compiler options 

OS/src/config_default.h
    includes configall_system.h and config_os_default.h
    sets project specific macros (all of the form COIN_HAS_XXX)

OS/src/config_os_default.h
    sets "project specific public macros" of the form OS_HAS_XXX

OS/src/config.h.in
     similar content to config_default, but exact settings are defined by the configure step, which creates OS/src/config.h in the vpath directory

OS/src/config_os.h.in
     similar content to config_os_default, but exact settings are defined by the configure step, which creates OS/src/configos_.h in the vpath directory

OSConfig.h
    unifies different compile situations by including one of the preceding four OS-specific config files

OSParameters.h
    includes OSConfig.h and defines additional constants (such as OSDBL_MAX, OS_EPS, etc.) and types (i.e., OsXmlInt and OsXmlUInt)
\end{verbatim}


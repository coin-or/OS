/* $Id$ */
/** @file OSnLNode.h
 * \brief This file defines the OSnLNode class along with its derived classes.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 *
 * \remarks
 * Copyright (C) 2005-2015, Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin,
 * Northwestern University, and the University of Chicago.
 * All Rights Reserved.
 * This software is licensed under the Eclipse Public License.
 * Please see the accompanying LICENSE file in root directory for terms.
 *
 *
 * In this file we define classes for a subset of the nodes defined in the OSnL schema
 * These nodes fall into three broad classes: 
 * Those that evaluate to real values (which inherit from OSnLNode),
 * those that evaluate to matrices (and inherit from OSnLMNode), and
 * those that evaluate to complex values (and inherit from OSnLCNode).
 * Real and complex-valued nodes derive from a common parent, ScalarNode,
 * which is derived from ExprNode.
 * OSnLNodes can have OSnLMNode children (e.g., matrixDeterminant) 
 * and vice versa (e.g., matrixScalarTimes); similarly for OSnLCNodes.
 */

#ifndef OSNLNODE_H
#define OSNLNODE_H

#include "OSConfig.h"
#include "OSGeneral.h"
#include "OSErrorClass.h"
#include <iostream>
#include <vector>
#include <map>
#include <complex>

#ifdef OS_HAS_CPPAD
# include <cppad/cppad.hpp>
typedef CppAD::AD<double>  ADdouble;
typedef CppAD::vector<ADdouble> ADvector;
#else
typedef double  ADdouble;
typedef std::vector<ADdouble> ADvector;
#endif

/**
 *  Some forward declarations to make sure circular references are handled properly.
 */
class OSnLNode;
class OSnLCNode;
class OSnLMNode;
class ScalarNode;
class OSMatrix;
class GeneralSparseMatrix;

/*! \class ExprNode 
 *  \brief A generic class from which we derive ScalarNode and OSnLMNode
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @version 2.9, 10/Sep/2014
 */
class ExprNode
{
public:

    /** inodeInt is the unique integer assigned to the OSnLNode, OSnLCNode or OSnLMNode.
     *  The master list is in OSParameters.h.
     */
    int inodeInt;

    /** inodeKind tracks the kind of value generated by the node
     *    = 1: node is real-valued; 
     *    = 2: node is complex-valued; 
     *    = 3: node is matrix-valued; 
     */
    int inodeKind;

    /**  inumberOfChildren is the number of OSnLNode child elements
     *   If this number is not fixed, e.g., for a sum node, it is temporarily set to 0
     */
    unsigned int inumberOfChildren;

    /**
     *  m_mChildren holds all the operands, that is, nodes that the current node operates on.
     *  @remark There is no distinction based on the kind of node (real-valued or otherwise)
     */
    ExprNode **m_mChildren;

    /**
     * default constructor.
     */
    ExprNode();

    /**
     * default destructor.
     */
    virtual ~ExprNode();

    /**
     * @return the value of the operator name
     */
    virtual std::string getTokenName() = 0;

    /**
     * @return the value of inodeInt (as a string) and related information
     */
    virtual std::string getTokenNumber();

    /**
     * A diagnostic tool to retrieve information about the ExprNode
     * @param  recurse controls whether the children of the node are accessed recursively
     * @param  indent controls the amount of indentation used to visualize the tree structure  
     * @return information associated with the ExprNode 
     *         and additional information (where appropriate) as a string.
     */
    virtual std::string getNodeInfo(bool recurse, int indent);

    /**
     * The following method writes an ExprNode in OSiL format.
     * It is used by OSiLWriter to assist in writing an OSiL file 
     * from a corresponding OSInstance.
     *
     * @return the ExprNode and its children as an OSiL string.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     * Get a vector of pointers to ExprNodes that correspond to
     * the (scalar-valued or matrix-valued) expression tree in prefix format.
     *
     * @return the expression tree as a vector of ExprNodes in prefix format.
     */
    std::vector<ExprNode*> getPrefixFromExpressionTree();

    /**
     * Called by getPrefixFromExpressionTree().  
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNode in prefix format.
     * 
     * @param a pointer prefixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNode in prefix.
     */
    std::vector<ExprNode*> preOrderOSnLNodeTraversal( std::vector<ExprNode*> *prefixVector);

    /**
     * Get a vector of pointers to ExprNodes that correspond to
     * the (scalar-valued or matrix-valued) expression tree in postfix format
     *
     * @return the expression tree as a vector of ExprNodes in postfix format..
     */
    std::vector<ExprNode*> getPostfixFromExpressionTree();

    /**
     * Called by getPostfixFromExpressionTree(). 
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNodes in postfix format.
     * 
     * @param a pointer postfixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNodes in postfix.
     */
    std::vector<ExprNode*> postOrderOSnLNodeTraversal( std::vector<ExprNode*> *postfixVector);

    /**
     * Take a vector of ExprNodes in prefix format and create an OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to ExprNodes in prefix format
     * @return a pointer to an ExprNode which is the root of an OSExpressionTree.
     */
    ExprNode* createExpressionTreeFromPrefix(std::vector<ExprNode*> nlNodeVec);

    /**
     * Take a vector of ExprNodes in postfix format and create an OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to ExprNodes in postfix format
     * @return a pointer to an ExprNode which is the root of an OSExpressionTree.
     */
    ExprNode* createExpressionTreeFromPostfix(std::vector<ExprNode*> nlNodeVec);

    /** Here we put several calculate functions that are used for different kinds of nodes
     *  They cannot be declared pure virtual because the return value depends on the
     *  kind of each node. For easier identification we use different function names as well.
     **/

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from the OSnLNode class.
     * Since expression trees can hold real-valued, complex-valued and matrix-valued nodes
     * in essentially arbitrary order, three different calculateFunctions must be
     * declared here in order for the recursion to work as intended.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     */
    virtual double calculateFunction(double *x);

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from the OSnLCNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    virtual std::complex<double> calculateFunction_C(double *x);

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from the OSnLMNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    virtual OSMatrix* calculateFunction_M(double *x);

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from the OSnLTNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    //virtual OSMatrix* calculateFunction_T(double *x);

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    //virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD) = 0;

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    //virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD) = 0;

    /**
     * Create or clone a node of this type.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this class.
     */
    virtual ExprNode *cloneExprNode() = 0;

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(ExprNode *that);
};//end ExprNode


/*! \class ScalarNode 
 *  \brief A generic class from which we derive OSnLNode and OSnLCNode
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @version 2.9, 10/Sep/2015
 */
class ScalarNode : public ExprNode
{
public:
    /**
     * default constructor.
     */
    ScalarNode();

    /**
     * default destructor.
     */
    virtual ~ScalarNode();

    /**
     * @return the value of the operator name
     */
    virtual std::string getTokenName();

    /**
     * @return the unique number assigned to the operator (see the list in OSParameters.h)
     *         and additional information (where appropriate) as a string.
     */
    virtual std::string getTokenNumber();

    /**
     * The following method writes an ExprNode in OSiL format.
     * It is used by OSiLWriter to assist in writing an OSiL file 
     * from a corresponding OSInstance.
     *
     * @return the ExprNode and its children as an OSiL string.
     */
    //virtual std::string getNonlinearExpressionInXML();

    /**
     * Create or clone a node of this type.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this class.
     */
    virtual ExprNode *cloneExprNode() = 0;

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(ScalarNode *that);
};//end ScalarNode

/*! \class OSnLNode 
 *  \brief The OSnLNode Class for nonlinear expressions.
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 */
class OSnLNode: public ScalarNode
{
public:
    /**
     * m_dFunctionValue holds the function value given the current variable values.
     */
    double m_dFunctionValue;

    /**
     * m_ADTape stores the expression tree for the this OSnLNode as an ADdouble.
     */
    ADdouble m_ADTape;


    /**
     * default constructor.
     */
    OSnLNode();

    /**
     * default destructor.
     */
    virtual ~OSnLNode();

    /**
     * varIdx is a map where the key is the index of an OSnLNodeVariable and
     * (*varIdx)[ idx] is the kth variable in the map, e.g.
     * (*varIdx)[ 5] = 2 means that variable indexed by 5 is the second variable
     * in the OSnLNode and all of its children
     * 
     * @param a pointer to a map of the variables in the OSnLNode and its children
     */
    virtual void getVariableIndexMap(std::map<int, int> *varIdx);

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     */
    virtual double calculateFunction(double *x) = 0;

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD) = 0;

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in prefix format
     * and create a scalar-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes and OSnLMNodes
     * in prefix format
     * @return a pointer to an OSnLNode which is the root of
     * an OSExpressionTree.
     */
    OSnLNode* createExpressionTreeFromPrefix(std::vector<ExprNode*> nlNodeVec);

#if 0
    /**
     * Get a vector of pointers to OSnLNodes and OSnLMNodes that correspond to
     * the (scalar-valued or matrix-valued) expression tree in prefix format.
     *
     * @return the expression tree as a vector of ExprNodes in prefix.
     */
    virtual std::vector<ExprNode*> getPrefixFromExpressionTree();

    /**
     * Called by getPrefixFromExpressionTree().  
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNode in prefix
     * 
     * @param a pointer prefixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNode in prefix.
     */
    virtual std::vector<ExprNode*> preOrderOSnLNodeTraversal( std::vector<ExprNode*> *prefixVector);
#endif

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in postfix format 
     * and create a scalar-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes
     * in postfix format
     * @return a pointer to an OSnLNode which is the root of
     * an OSExpressionTree.
     */
    OSnLNode* createExpressionTreeFromPostfix(std::vector<ExprNode*> nlNodeVec);

#if 0
    /**
     * Get a vector of pointers to ExprNodes that correspond to
     * the expression tree in postfix format
     *
     * @return the expression tree as a vector of ExprNodes in postfix.
     */
    virtual std::vector<ExprNode*> getPostfixFromExpressionTree();

    /**
     * Called by getPostfixFromExpressionTree(). 
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNodes in postfix.
     * 
     * @param a pointer postfixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNodes in postfix.
     */
    virtual std::vector<ExprNode*> postOrderOSnLNodeTraversal( std::vector<ExprNode*> *postfixVector);
#endif

    /**
     * Create or clone a node of this type.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this class.
     */
    //virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    bool IsEqual(OSnLNode *that);
};//end OSnLNode


/*! \class OSnLNodePlus
 *  \brief The OSnLNodePlus Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <plus>
 *
 */
class OSnLNodePlus : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodePlus();

    /**
     * default destructor.
     */
    virtual ~OSnLNodePlus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodePlus::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodePlus::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode()
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodePlus

/*! \class OSnLNodeSum
 *  \brief The OSnLNodeSum Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <sum>
 *
 */
class OSnLNodeSum : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeSum();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeSum();

    /**
     * @return the value of the operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeSum::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /*! \fn double OSnLNodeSum::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);
};//end OSnLNodeSum

/*! \class OSnLNodeMax
 *  \brief The OSnLNodeMax Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <max>
 *
 */
class OSnLNodeMax : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMax();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMax();

    /**
     * @return the value of the operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMax::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMax::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMax

/*! \class OSnLNodeMin
 *  \brief The OSnLNodeMin Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <min>
 *
 */
class OSnLNodeMin : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMin();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMin();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMin::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMin::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMin


/*! \class OSnLNodeMinus
 *  \brief The OSnLNodeMinus Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <minus>
 *
 */
class OSnLNodeMinus : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMinus();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMinus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMinus::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMinus::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMinus


/*! \class OSnLNodeNegate
 *  \brief The OSnLNodeNegate Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <negate>
 *
 */
class OSnLNodeNegate : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeNegate();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeNegate();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeNegate::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeNegate::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeNegate


/*! \class OSnLNodeTimes
 *  \brief The OSnLNodeTimes Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <times>
 *
 */
class OSnLNodeTimes : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeTimes();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeTimes();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeTimes::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeNegate::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeTimes


/*! \class OSnLNodeDivide
 *  \brief The OSnLNodeDivide Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <divide>
 *
 */
class OSnLNodeDivide : public OSnLNode

{
public:
    /**
     * default constructor.
     */
    OSnLNodeDivide();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeDivide();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeDivide::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeDivide::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeDivide


/*! \class OSnLNodePower
 *  \brief The OSnLNodePower Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <power>
 *
 */
class OSnLNodePower : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodePower();

    /**
     * default destructor.
     */
    virtual ~OSnLNodePower();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodePower::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodePower::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodePower


/*! \class OSnLNodeProduct
 *  \brief The OSnLNodeProduct Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <product>
 *
 */
class OSnLNodeProduct : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeProduct();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeProduct();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeProduct::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeProduct::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeProduct


/*! \class OSnLNodeLn
 *  \brief The OSnLNodeLn Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <ln>
 *
 */
class OSnLNodeLn : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeLn();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeLn();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeLn::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeLn::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeLn


/*! \class OSnLNodeSqrt
 *  \brief The OSnLNodeSqrt Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <sqrt>
 *
 */
class OSnLNodeSqrt : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeSqrt();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeSqrt();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeSqrt::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeSqrt::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeSqrt


/*! \class OSnLNodeSquare
 *  \brief The OSnLNodeSquare Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <square>
 *
 */
class OSnLNodeSquare : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeSquare();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeSquare();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeSquare::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeSquare::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeSquare


/*! \class OSnLNodeCos
 *  \brief The OSnLNodeCos Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <cos>
 *
 */
class OSnLNodeCos : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeCos();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeCos();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeCos::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeCos::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeCos


/*! \class OSnLNodeSin
 *  \brief The OSnLNodeSin Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <sin>
 *
 */
class OSnLNodeSin : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeSin();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeSin();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeSin::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeSin::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeSin


/*! \class OSnLNodeExp
 *  \brief The OSnLNodeExp Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <exp>
 *
 */
class OSnLNodeExp : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeExp();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeExp();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeExp::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeExp::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeExp


/*! \class OSnLNodeAbs
 *  \brief The OSnLNodeAbs Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <abs>
 *
 */
class OSnLNodeAbs : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeAbs();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeAbs();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeAbs::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeAbs::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeAbs


/*! \class OSnLNodeErf
 *  \brief The OSnLNodeErf Class.

 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <ln>
 *
 */
class OSnLNodeErf : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeErf();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeErf();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeErf::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeLn::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeErf


/*! \class OSnLNodeIf
 *  \brief The OSnLNodeIf Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <if>
 *
 */
class OSnLNodeIf : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeIf();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeIf();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeIf::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeIf::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeIf


/*! \class OSnLNodeNumber
 *  \brief The OSnLNodeNumber Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <number>
 *
 */
class OSnLNodeNumber : public OSnLNode
{
public:
    /** value is the value of the number */
    double value;

    /** in the C++ implementation, type is "real" */
    std::string type;

    /** later, e.g. stochastic programming, we may wish
     * to give an id to a number
     */
    std::string id;

    /**
     * default constructor.
     */
    OSnLNodeNumber();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeNumber();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * A diagnostic tool to retrieve information about the ExprNode
     * @param  recurse controls whether the children of the node are accessed recursively
     * @param  indent controls the amount of indentation used to visualize the tree structure  
     * @return information associated with the ExprNode 
     *         and additional information (where appropriate) as a string.
     */
    virtual std::string getNodeInfo(bool recurse, int indent);

    /**
     * @return the OSiL XML for the number node.
     */
    virtual std::string getNonlinearExpressionInXML();

    /*! \fn double OSnLNodeNumber::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeNumber::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLNodeNumber *that);
};//end OSnLNodeNumber


/*! \class OSnLNodeE
 *  \brief The OSnLNodeE Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <E>
 *
 */
class OSnLNodeE : public OSnLNode
{
public:

    /**
     * default constructor.
     */
    OSnLNodeE();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeE();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenName();

    /**
     * @return the OSiL XML for the number node.
     */
    virtual std::string getNonlinearExpressionInXML();

    /*! \fn double OSnLNodeE::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeE::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeE


/*! \class OSnLNodePI
 *  \brief The OSnLNodePI Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <pi>
 *
 */
class OSnLNodePI : public OSnLNode
{
public:

    /**
     * default constructor.
     */
    OSnLNodePI();

    /**
     * default destructor.
     */
    virtual ~OSnLNodePI();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenName();

    /**
     * @return the OSiL XML for the number node.
     */
    virtual std::string getNonlinearExpressionInXML();

    /*! \fn double OSnLNodePI::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodePI::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodePI


/*! \class OSnLNodeVariable
 *  \brief The OSnLNodeVariable Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <variable>
 *
 */
class OSnLNodeVariable : public OSnLNode
{
public:

    /** coef is an optional coefficient on the variable;
     *  the default value is 1.0
     */
    double coef;

    /** idx is the index of the variable */
    int idx;

    /**
     * default constructor.
     */
    OSnLNodeVariable();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeVariable();

    virtual void getVariableIndexMap(std::map<int, int> *varIdx);

    /**
     * @return a std::string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * A diagnostic tool to retrieve information about the ExprNode
     * @param  recurse controls whether the children of the node are accessed recursively
     * @param  indent controls the amount of indentation used to visualize the tree structure  
     * @return information associated with the ExprNode 
     *         and additional information (where appropriate) as a string.
     */
    virtual std::string getNodeInfo(bool recurse, int indent);

    /**
     * @return the OSiL XML for the variable node.
     */
    virtual std::string getNonlinearExpressionInXML();

    /*! \fn double OSnLNodeVariable::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeVariable::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLNodeVariable *that);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeVariable


/*! \class OSnLNodeAllDiff
 *  \brief The OSnLNodeAllDiff Class.
 *
 * @author  Robert Fourer, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <alldiff>
 *
 */
class OSnLNodeAllDiff : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeAllDiff();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeAllDiff();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeAllDiff::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeAllDiff::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeAllDiff


/** The next few nodes evaluate to a scalar even though one or more of its arguments are matrices **/

/*! \class OSnLNodeMatrixDeterminant
 *  \brief The OSnLNodeMatrixDeterminant Class.
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @date    11/06/2014
 * @since   OS2.8
 *
 * \remarks
 * The in-memory representation of the OSnL element <matrixDeterminant>
 *
 */
class OSnLNodeMatrixDeterminant : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMatrixDeterminant();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMatrixDeterminant();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMatrixDeterminant::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMatrixDeterminant::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNodeMatrixDeterminant *cloneExprNodeMatrixDeterminant(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNodeMatrixDeterminant of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMatrixDeterminant

/*! \class OSnLNodeMatrixTrace
 *  \brief The OSnLNodeMatrixTrace Class.
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @date    11/06/2014
 * @since   OS2.8
 *
 * \remarks
 * The in-memory representation of the OSnL element <matrixTrace>
 *
 */
class OSnLNodeMatrixTrace : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMatrixTrace();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMatrixTrace();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMatrixTrace::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMatrixTrace::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNodeMatrixTrace *cloneExprNodeMatrixTrace(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNodeMatrixTrace of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMatrixTrace

/*! \class OSnLNodeMatrixToScalar
 *  \brief The OSnLNodeMatrixTrace Class.
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @date    11/06/2014
 * @since   OS2.8
 *
 * \remarks
 * The in-memory representation of the OSnL element <matrixToScalar>
 *
 */
class OSnLNodeMatrixToScalar : public OSnLNode
{
public:
    /**
     * default constructor.
     */
    OSnLNodeMatrixToScalar();

    /**
     * default destructor.
     */
    virtual ~OSnLNodeMatrixToScalar();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeMatrixTrace::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */
    virtual double calculateFunction( double *x);

    /*! \fn double OSnLNodeMatrixTrace::constructADTape(std::map<int, int> *ADIdx, vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD);

    /*! \fn OSnLNodeMatrixTrace *cloneExprNodeMatrixTrace(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNodeMatrixTrace of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLNodeMatrixToScalar


/*! \class OSnLMNode 
 *  \brief The OSnLMNode Class for nonlinear expressions involving matrices
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @date    11/06/2014
 * @since   OS2.8
 */
class OSnLMNode: public ExprNode
{
private:
#if 0
    /**
     *  This parameter holds the types of elements found in this node
     *
     *  For types supported, see OSParameters.h
     */
    ENUM_MATRIX_TYPE valueType;
#endif

public:

    /**
     * default constructor.
     */
    OSnLMNode();

    /**
     * default destructor.
     */
    virtual ~OSnLMNode();

#if 0
    /**
     *  a utility routine to determine the type of values held in this node
     */
    virtual ENUM_MATRIX_TYPE getValueType(OSMatrix** mtxLoc);
#endif

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return whether the expansion was successful
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown) = 0;

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in prefix format
     * and create a matrix-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes and OSnLMNodes
     * in prefix format
     * @return a pointer to an OSnLMNode which is the root of
     * an OSExpressionTree.
     */
    OSnLMNode* createExpressionTreeFromPrefix(std::vector<ExprNode*> nlNodeVec);

#if 0
    /**
     * Get a vector of pointers to OSnLNodes and OSnLMNodes that correspond to
     * the (matrix-valued) expression tree in prefix format.
     *
     * @return the expression tree as a vector of ExprNodes in prefix.
     */
    std::vector<ExprNode*> getPrefixFromExpressionTree();

    /**
     * Called by getPrefixFromExpressionTree().  
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNode in prefix
     * 
     * @param a pointer prefixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNode in prefix.
     */
    std::vector<ExprNode*> preOrderOSnLNodeTraversal( std::vector<ExprNode*> *prefixVector);
#endif

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in postfix format
     * and create a matrix-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes and OSnLMNodes
     * in postfix format
     * @return a pointer to an OSnLMNode which is the root of
     * an OSExpressionTree.
     */
    OSnLMNode* createExpressionTreeFromPostfix(std::vector<ExprNode*> nlNodeVec);

#if 0
    /**
     * Get a vector of pointers to ExprNodes that correspond to
     * the expression tree in postfix format
     *
     * @return the expression tree as a vector of ExprNodes in postfix.
     */
    std::vector<ExprNode*> getPostfixFromExpressionTree();

    /**
     * Called by getPostfixFromExpressionTree(). 
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNodes in postfix.
     * 
     * @param a pointer postfixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNodes in postfix.
     */
    std::vector<ExprNode*> postOrderOSnLNodeTraversal( std::vector<ExprNode*> *postfixVector);
#endif

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from the OSnLMNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return the function value given the current variable values.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    //virtual OSMatrix* calculateFunction_M(double *x);

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     * @remark this function will have different return value when implemented in
     *         OSnLNode, OSnLMNode and OSnLCNode as well as their descendants.
     */
    //virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD) = 0;

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    //virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    bool IsEqual(OSnLMNode *that);
};//end OSnLMNode

class OSnLMNodeMatrixPlus : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixPlus();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixPlus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     *
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixPlus

class OSnLMNodeMatrixSum : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixSum();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixSum();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixSum

class OSnLMNodeMatrixMinus : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixMinus();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixMinus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixMinus

class OSnLMNodeMatrixNegate : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixNegate();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixNegate();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixNegate

class OSnLMNodeMatrixTimes : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixTimes();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixTimes();

#if 0
    /**
     *  a utility routine to determine the type of values held in this node
     */
    virtual ENUM_MATRIX_TYPE getValueType(OSMatrix** mtxLoc);
#endif

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixTimes

#if 0
/*! \class OSnLMNodeMatrixProduct
 *  \brief The OSnLMNodeMatrixProduct Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 10/05/2005
 * @since   OS1.0
 *
 * \remarks
 * The in-memory representation of the OSnL element <matrixProduct>
 *
 */
class OSnLMNodeMatrixProduct : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixProduct();

    /**
     * default destructor.
     */
    ~OSnLMNodeMatrixProduct();

    /**
     *
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual OSnLNode *cloneExprNode();
};//end OSnLMNodeMatrixProduct
#endif

class OSnLMNodeMatrixInverse : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixInverse();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixInverse();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixInverse

class OSnLMNodeMatrixTranspose : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixTranspose();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixTranspose();

#if 0
    /**
     *  a utility routine to determine the type of values held in this node
     */
    virtual ENUM_MATRIX_TYPE getValueType(OSMatrix** mtxLoc);
#endif

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixTranspose

class OSnLMNodeMatrixScalarTimes : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixScalarTimes();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixScalarTimes();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixScalarTimes

class OSnLMNodeMatrixDotTimes : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixDotTimes();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixDotTimes();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixDotTimes

class OSnLMNodeIdentityMatrix : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeIdentityMatrix();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeIdentityMatrix();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeIdentityMatrix

class OSnLMNodeMatrixLowerTriangle : public OSnLMNode
{
public:
    /**
     *  A boolean to express whether the diagonal is to be part of the upper triangle or not
     */
    bool includeDiagonal;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixLowerTriangle();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixLowerTriangle();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixLowerTriangle *that);
};//end OSnLMNodeMatrixLowerTriangle

class OSnLMNodeMatrixUpperTriangle : public OSnLMNode
{
public:
    /**
     *  A boolean to express whether the diagonal is to be part of the upper triangle or not
     */
    bool includeDiagonal;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixUpperTriangle();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixUpperTriangle();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixUpperTriangle *that);
};//end OSnLMNodeMatrixUpperTriangle


class OSnLMNodeMatrixDiagonal : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixDiagonal();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixDiagonal();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixDiagonal

class OSnLMNodeDiagonalMatrixFromVector : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeDiagonalMatrixFromVector();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeDiagonalMatrixFromVector();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeDiagonalMatrixFromVector


class OSnLMNodeMatrixSubmatrixAt : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixSubmatrixAt();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixSubmatrixAt();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
//    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrix>.
     */
//    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixSubmatrixAt


class OSnLMNodeMatrixReference : public OSnLMNode
{
public:
    /**
     *  The index of the matrix
     */
    int idx;

    /**
     *  To indicate whether the matrix is to be transposed
     */
    bool transpose;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixReference();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixReference();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

#if 0
    /**
     *  a utility routine to determine the type of values held in this node
     */
    virtual ENUM_MATRIX_TYPE getValueType(OSMatrix** mtxLoc);
#endif

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * A diagnostic tool to retrieve information about the ExprNode
     * @param  recurse controls whether the children of the node are accessed recursively
     * @param  indent controls the amount of indentation used to visualize the tree structure  
     * @return information associated with the ExprNode 
     *         and additional information (where appropriate) as a string.
     */
    virtual std::string getNodeInfo(bool recurse, int indent);

    /**
     * @return the OSiL XML for the OSnLMNode <matrixReference>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixReference *that);
};//end OSnLMNodeMatrixReference


class OSnLMNodeMatrixVar : public OSnLMNode
{
public:
    /**
     *  The index of the matrixVar
     */
     int idx;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixVar();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixVar();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrixReference>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixVar *that);
};//end OSnLMNodeMatrixVar


class OSnLMNodeMatrixObj : public OSnLMNode
{
public:
    /**
     *  The index of the matrixObj
     */
     int idx;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixObj();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixObj();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrixObj>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixObj *that);
};//end OSnLMNodeMatrixObj


class OSnLMNodeMatrixCon : public OSnLMNode
{
public:
    /**

     *  The index of the matrixCon
     */
     int idx;

    /**
     * default constructor.
     */
    OSnLMNodeMatrixCon();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixCon();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /**
     * @return a string token that corresponds to the OSnLNode.
     */
    virtual std::string getTokenNumber();

    /**
     * @return the OSiL XML for the OSnLMNode <matrixCon>.
     */
    virtual std::string getNonlinearExpressionInXML();

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLMNode *cloneOSnLMNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    virtual bool IsEqual(OSnLMNodeMatrixCon *that);
};//end OSnLMNodeMatrixCon


/*! \class OSnLMNodeMatrixProduct
 *  \brief The OSnLMNodeMatrixProduct Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 08/Dec/2014
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <matrixProduct>
 *
 */
class OSnLMNodeMatrixProduct : public OSnLMNode
{
public:
    /**
     * default constructor.
     */
    OSnLMNodeMatrixProduct();

    /**
     * default destructor.
     */
    virtual ~OSnLMNodeMatrixProduct();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn double OSnLNodeProduct::double(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a double.
     */    
    //virtual double calculateFunction( double *x);

    /*! \fn double OSnLMNodeMatrixProduct::constructADTape(std::map<int, int> *ADIdx, 
     *                                                     vector< ADdouble > *XAD)
     *  \brief The implementation of the virtual functions.
     *  \return a ADdouble.
     */
    //virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD); 

    /**
     *  a utility routine to expand an OSNlMNode into one of several different forms
     *  @param mtxLoc     pointer array to all defined matrices to resolve matrix references
     *  @param rowMajor_  controls whether the matrix should be expanded into row or column major format
     *  @param convertTo_ controls whether elements should be converted from one type to another
     *  @param symmetry_  controls whether a particular type of symmetry should be enforced
     *                    The default value does not change the symmetry 
     *  @return the expanded matrix node
     */
    virtual GeneralSparseMatrix* 
        expandNode(OSMatrix** mtxLoc, bool rowMajor_, 
                   ENUM_MATRIX_TYPE convertTo_    = ENUM_MATRIX_TYPE_unknown,
                   ENUM_MATRIX_SYMMETRY symmetry_ = ENUM_MATRIX_SYMMETRY_unknown);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLMNodeMatrixProduct


/*! \class OSnLCNode 
 *  \brief The OSnLCNode Class for complex-valued expressions.
 *
 * @author  Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 28/Sep/2015
 * @since   OS2.9
 */
class OSnLCNode: public ScalarNode
{
public:
    /**
     * m_dFunctionValue    holds the function value given the current variable values.
     */
    std::complex<double> m_dFunctionValue;

    /**
     * m_ADTape stores the expression tree for the this OSnLNode as an ADdouble.
     */
    ADdouble m_ADTape;


    /**
     * default constructor.
     */
    OSnLCNode();

    /**
     * default destructor.
     */
    virtual ~OSnLCNode();

    /**
     * Calculate the function value given the current variable values.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLCNode class.
     *
     * @param x holds the values of the variables in a double array.
     * @return nothing, but store the function value given the current variable values
     *         into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C(double *x) = 0;

    /**
     * Create the AD tape to be evaluated by AD.
     * This is an abstract method which is required to be implemented by the concrete
     * operator nodes that derive or extend from this OSnLNode class.
     *
     * @return the expression tree.
     */
    //virtual ADdouble constructADTape(std::map<int, int> *ADIdx, ADvector *XAD) = 0;

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in prefix format
     * and create a scalar-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes and OSnLMNodes
     * in prefix format
     * @return a pointer to an OSnLCNode which is the root of
     * a complex-valued expression tree.
     */
    OSnLCNode* createExpressionTreeFromPrefix(std::vector<ExprNode*> nlNodeVec);

    /**
     * Get a vector of pointers to OSnLNodes and OSnLMNodes that correspond to
     * the (scalar-valued or matrix-valued) expression tree in prefix format.
     *
     * @return the expression tree as a vector of ExprNodes in prefix.
     */
    //virtual std::vector<ExprNode*> getPrefixFromExpressionTree();

    /**
     * Called by getPrefixFromExpressionTree().  
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNode in prefix
     * 
     * @param a pointer prefixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNode in prefix.
     */
    //virtual std::vector<ExprNode*> preOrderOSnLNodeTraversal( std::vector<ExprNode*> *prefixVector);

    /**
     * Take a vector of ExprNodes (OSnLNodes and OSnLMNodes) in postfix format 
     * and create a scalar-valued OSExpressionTree root node
     * 
     * @param nlNodeVec holds a vector of pointers to OSnLNodes
     * in postfix format
     * @return a pointer to an OSnLNode which is the root of
     * an OSExpressionTree.
     */
    //OSnLCNode* createExpressionTreeFromPostfix(std::vector<ExprNode*> nlNodeVec);

    /**
     * Get a vector of pointers to ExprNodes that correspond to
     * the expression tree in postfix format
     *
     * @return the expression tree as a vector of ExprNodes in postfix.
     */
    //virtual std::vector<ExprNode*> getPostfixFromExpressionTree();

    /**
     * Called by getPostfixFromExpressionTree(). 
     * This method calls itself recursively and
     * generates a vector of pointers to ExprNodes in postfix.
     * 
     * @param a pointer postfixVector to a vector of pointers of ExprNodes
     * @return a vector of pointers to ExprNodes in postfix.
     */
    //virtual std::vector<ExprNode*> postOrderOSnLNodeTraversal( std::vector<ExprNode*> *postfixVector);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    //virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    bool IsEqual(OSnLCNode *that);
};//end OSnLCNode


/*! \class OSnLCNodeCreate
 *  \brief The OSnLCNodeCreate Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexCreate>
 *
 */
class OSnLCNodeCreate : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeCreate();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeCreate();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodePlus::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLCNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeCreate


/*! \class OSnLCNodePlus
 *  \brief The OSnLCNodePlus Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexPlus>
 *
 */
class OSnLCNodePlus : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodePlus();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodePlus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodePlus::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodePlus


/*! \class OSnLCNodeMinus
 *  \brief The OSnLCNodeMinus Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexMinus>
 *
 */
class OSnLCNodeMinus : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeMinus();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeMinus();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeMinus::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.

     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeMinus


/*! \class OSnLCNodeNegate
 *  \brief The OSnLCNodeNegate Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexNegate>
 *
 */
class OSnLCNodeNegate : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeNegate();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeNegate();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeNegate::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeNegate


/*! \class OSnLCNodeConjugate
 *  \brief The OSnLCNodeConjugate Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexConjugate>
 *
 */
class OSnLCNodeConjugate : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeConjugate();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeConjugate();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeConjugate::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeConjugate


/*! \class OSnLCNodeSum
 *  \brief The OSnLCNodePlus Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexSum>
 *
 */
class OSnLCNodeSum : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeSum();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeSum();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeSum::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLCNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeSum


/*! \class OSnLCNodeTimes
 *  \brief The OSnLCNodeTimes Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexTimes>
 *
 */
class OSnLCNodeTimes : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeTimes();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeTimes();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeTimes::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeTimes


/*! \class OSnLCNodeSquare
 *  \brief The OSnLCNodeSquare Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexSquare>
 *
 */
class OSnLCNodeSquare : public OSnLCNode
{
public:
    /**
     * default constructor.
     */
    OSnLCNodeSquare();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeSquare();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn void OSnLCNodeSquare::calculateFunction(double *x)

     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn OSnLCNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();
};//end OSnLCNodeSquare


/*! \class OSnLCNodeNumber
 *  \brief The OSnLCNodeNumber Class.
 *
 * @author  Robert Fourer, Horand Gassmann, Jun Ma, Kipp Martin
 * @version 1.0, 29/Sep/2015
 * @since   OS2.9
 *
 * \remarks
 * The in-memory representation of the OSnL element <complexNumber>
 *
 */
class OSnLCNodeNumber : public OSnLCNode
{
private:
    /**
     * value, stored as a std::complex<double>, even though the OSiL schema stores the
     *        real and imaginary parts as separate attributes
     */
    std::complex<double> value;

    /**
     * id can be used to reference an entry in a pool of numbers
     */
    int id;

    /**   
     *  realtime can be used to signal any part of the number that will be resolved in real time
     *  The default is "none"
     */
    ENUM_COMPLEX_NUMBER_PART realTime;

    /**   
     *  random can be used to signal any part of the number that is random
     *  The default is "none"
     */


    ENUM_COMPLEX_NUMBER_PART random;

public:
    /**
     * default constructor.
     */
    OSnLCNodeNumber();

    /**
     * default destructor.
     */
    virtual ~OSnLCNodeNumber();

    /**
     * @return the value of operator name
     */
    virtual std::string getTokenName();

    /*! \fn std::string OSnLCNodeNumber::getNonlinearExpressionInXML()
     *  \brief The implementation of the virtual function.
     *  \return the XML representation, including two attributes 
     */
    virtual std::string getNonlinearExpressionInXML();

    /*! \fn void OSnLCNodeNumber::calculateFunction(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return nothing, but store function value into m_dFunctionValue.
     */
    virtual std::complex<double> calculateFunction_C( double *x);

    /*! \fn std::complex<double> getValue()
     *  \brief return the value of a complex number 
     */
    std::complex<double> getValue();

    /*! \fn void setValue(double Re, double Im)
     *  \brief create the value of a complex number from the real and imaginary parts
     */
    void setValue(double Re, double Im);

    /*! \fn void setValue(std::complex<double> z)
     *  \brief store the value of a complex number z into the data structure
     */
    void setValue(std::complex<double> z);

    /*! \fn OSnLNode *cloneExprNode(double *x)
     *  \brief The implementation of the virtual functions.
     *  \return a pointer to a new OSnLMNode of the proper type.
     */
    virtual ExprNode *cloneExprNode();

    /**
     * A function to check for the equality of two objects
     */
    bool IsEqual(OSnLCNodeNumber *that);
};//end OSnLCNodeNumber



/*
TO DO:

1.  Allow for a variable node with a child

2.  When we create the Expression Tree from postfix, do we check if the coefficient of a variable is 1?
*/
#endif



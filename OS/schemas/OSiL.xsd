<?xml version="1.0" encoding="utf-8"?>
<!-- edited with XMLSpy v2008 (http://www.altova.com) by Gus Gassmann (Dalhousie University) -->
<!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by Jun Ma (Northwestern University) -->
<!-- schema stage stamping: experiment -> draft -> proposal -> recommendation -> finalization -> version 1.0, 1.1, 2.0, ... -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="os.optimizationservices.org" targetNamespace="os.optimizationservices.org" elementFormDefault="qualified">
	<!--OSiL.xsd: version 2.0 -->
	<xs:include schemaLocation="OSgL.xsd"/>
	<xs:include schemaLocation="OSnL.xsd"/>
	<xs:include schemaLocation="OSsL.xsd"/>
	<xs:element name="osil" type="OSiL"/>
	<!--OSiL: since version 1.0 -->
	<xs:complexType name="OSiL">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="instanceHeader" type="GeneralFileHeader">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:element name="instanceData" type="InstanceData"/>
				<xs:element name="modifications" type="InstanceModifications">
					<xs:annotation>
						<xs:documentation>experiment</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<!--InstanceData: since version 1.0 -->
	<xs:complexType name="InstanceData">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:group ref="CoreData"/>
			<xs:group ref="DefinitionData"/>
			<xs:group ref="ExtensionData"/>
		</xs:sequence>
	</xs:complexType>
	<xs:group name="CoreData">
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="LinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0 - Does not use matrices. So, e.g. the expression 4x + 5y + x^2 + 2xy + 3y^2 has three quadratic coefficients: 1, 2, 3</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="specialOrderedSets" type="SpecialOrderedSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0
We use the LPSOLVE definition of SOS, which goes back to a paper by J.A.Tomlin in "Studies on Graphs and Discrete Programming", 1981. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="DefinitionData">
		<xs:sequence>
			<xs:element name="matrices" type="Matrices" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensors" type="Tensors" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="distributions" type="Distributions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="userFunctions" type="UserFunctions_p" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="externalFunctions" type="ExternalFunctions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="xmlData" type="XMLData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<xs:group name="ExtensionData">
		<xs:sequence>
			<xs:element name="matrixProgramming" type="MatrixProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexProgramming" type="ComplexProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorProgramming" type="TensorProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveProgramming" type="DisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeDataProgramming" type="RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="multilevelAndStochasticProgramming" type="MultilevelAndStochasticProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="parametricAnalysis" type="ParametricAnalysis" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!--Variables: since version 1.0 -->
	<xs:complexType name="Variables">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the var child elements must agree with numberOfVariables (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="Variable" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>semi-continuous (D) and semi-integer (J) types added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Variable">
		<xs:annotation>
			<xs:documentation>since version 1.0. Variable type "D" (semi-continuous) and "J" (semi-integer) since 2.0.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>C - continuous
B- binary
I - integer
S - string
D - semi-continuous
J - semi-integer</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<!--Objectives: since version 1.0-->
	<xs:complexType name="Objectives">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the obj child elements must agree with numberOfObjectives (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="Objective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="Objective">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number of coef child elements must match numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>If idx is repeated, the objective terms/coefficients are added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="maxOrMin" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="weight" type="xs:double" use="optional"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ObjCoef">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--Constraints: since version 1.0 -->
	<xs:complexType name="Constraints">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="Constraint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Constraint">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<!--LinearConstraintCoefficients: since version 1.0 -->
	<xs:complexType name="LinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>Number of entries in the start element must equal numberOfVariables + 1 (if columnMajor) or numberOfConstraints + 1 (if rowMajor), after considering "mult".                           Number of entries in the value and rowIdx/colIdx child elements must agree with numberOfValues (after "mult" has been considered). Multiple coefficients in the same location are added together.</xs:documentation>
			</xs:annotation>
			<xs:element name="start" type="SizelessNonNegativeIntVector"/>
			<xs:choice>
				<xs:element name="rowIdx" type="SizelessNonNegativeIntVector"/>
				<xs:element name="colIdx" type="SizelessNonNegativeIntVector"/>
			</xs:choice>
			<xs:element name="value" type="SizelessDoubleVector"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--QuadraticCoefficients; since version 1.0 -->
	<xs:complexType name="QuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms </xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="QuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="QuadraticTerm">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of the constraint or objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the first variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the second variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1">
			<xs:annotation>
				<xs:documentation>coefficient of the
quadratic term</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--NonlinearExpressions: since version 1.0 -->
	<xs:complexType name="NonlinearExpressions">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the child nl elements must agree with numberOfNonlinearExpressions</xs:documentation>
			</xs:annotation>
			<xs:element name="nl" type="Nl" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>shape attribute added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfNonlinearExpressions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Nl">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of constraint or objective row</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="unknown">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="concave"/>
					<xs:enumeration value="general"/>
					<xs:enumeration value="unknown"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -->
	<xs:complexType name="NonlinearComplexValuedExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="NonlinearComplexValuedExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NonlinearComplexValuedExpression">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing complex-valued objectives (if negative) or complex-valued constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--MatrixProgramming: proposal-->
	<xs:complexType name="MatrixProgramming">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0"/>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Like scalar objectives,  additional matrix objectives are added below the indices of previously defined matrix objectives.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0"/>
			<xs:element name="matrixExpressions" type="MatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For matrix-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MatrixVariables">
		<xs:sequence>
			<xs:element name="matrixVar" type="MatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixVar">
		<xs:sequence>
			<xs:element name="descriptor" type="MatrixVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptors
can be used, e.g., to set up Toeplitz or Cauchy matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only variables in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix variable has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core variables instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all variables indicated  by the use of the template matrix are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varType" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>same type for every newly created variable; default is 'C'; variables inherited from the core keep the type and bounds declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains varMtx - lbMtx; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx - varMtx; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created variable; default is 0; variables inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="MatrixVarOrConDescriptor" mixed="true">
		<xs:attribute name="name" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:minLength value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" use="optional"/>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="MatrixObjectives">
		<xs:sequence>
			<xs:element name="matrixObj" type="MatrixObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixObj">
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only objectives in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix objective has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="objReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core objectives instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all objectives indicated  by the use of the template matrix are created fresh. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. If reference uses only core objectives, orderConeIdx can be omitted and defaults to the corresponding orthant cone</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constantMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective;        zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created objective; default is 0; objectives inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="MatrixConstraints">
		<xs:sequence>
			<xs:element name="matrixCon" type="MatrixCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixCon">
		<xs:sequence>
			<xs:element name="descriptor" type="MatrixVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptors
can be used, e.g., to set up Toeplitz matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only variables in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix constraint has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core constraints instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all constraints indicated  by the use of the template matrix are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains mtx expr - lbMtx; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx -  mtx expr; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overriden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created constraint; default is 0; constraints inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="MatrixExpressions">
		<xs:sequence>
			<xs:element name="expr" type="MatrixExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixExpression">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLMNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing matrix objective (if negative) or matrix constraint (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--ComplexProgramming: experiment-->
	<xs:complexType name="ComplexProgramming">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0"/>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0"/>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0"/>
			<xs:element name="complexExpressions" type="ComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For complex-valued expressions only - real-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ComplexVariables">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexVar" type="ComplexVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexVar">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lbRealPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbImaginaryPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains var - lb; assumed all of C if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubRealPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubImaginaryPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ub - var; assumed all of C if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexObjectives">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexObj" type="ComplexObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexObj">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="additiveConstantRealPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective; Zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="additiveConstantImaginaryPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective; Zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexConstraints">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexCon" type="ComplexCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexCon">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lbRealPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>real part of the lower bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbImaginaryPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>imaginary part of the lower bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains mtx expr - lbMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubRealPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>real part of the upper bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubImaginaryPart" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>imaginary part of the upper bound</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx -  mtx expr; assumed all of C if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="ComplexExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexExpression">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing complex objectives (if negative) or complex constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--TensorProgramming: experiment-->
	<xs:complexType name="TensorProgramming">
		<xs:annotation>
			<xs:documentation>experiment--</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="tensorVariables" type="TensorVariables" minOccurs="0"/>
			<xs:element name="tensorObjectives" type="TensorObjectives" minOccurs="0"/>
			<xs:element name="tensorConstraints" type="TensorConstraints" minOccurs="0"/>
			<xs:element name="tensorExpressions" type="TensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For tensor-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="TensorVariables">
		<xs:sequence>
			<xs:element name="tensorVar" type="TensorVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorVar">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="descriptor" type="TensorVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptors
can be used to set up special tensors with properties not otherwise available</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor variable has a nonzero entry wherever the template tensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core variables instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all variables indicated  by the use of the template tensor are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varType" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>same type for every newly created variable; default is 'C'; variables inherited from the core keep the type and bounds declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains tensorVar - lbTensor; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubTensor - tensorVar; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created variable; default is 0; variables inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="TensorVarOrConDescriptor" mixed="true">
		<xs:attribute name="name" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:minLength value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" use="optional"/>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="TensorObjectives">
		<xs:sequence>
			<xs:element name="tensorObj" type="TensorObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorObj">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor objective has a nonzero entry wherever the template tensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="objReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core objectives instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all objectives indicated  by the use of the template tensor are created fresh. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. If reference uses only core objectives, orderConeIdx can be omitted and defaults to the corresponding orthant cone</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constantTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective;        zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created objective; default is 0; objectives inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="TensorConstraints">
		<xs:sequence>
			<xs:element name="tensorCon" type="TensorCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorCon">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="descriptor" type="TensorVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptors
can be used, e.g., to set up Toeplitz matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor constraint has a nonzero entry wherever the template tensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core constraints instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all constraints indicated  by the use of the template tensor are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains tensor expr - lbTensor; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubTensor - tensor expr; assumed nonbinding if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section. Same stage for every newly created constraint; default is 0; constraints inherited from the core keep the stage declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="TensorExpressions">
		<xs:sequence>
			<xs:element name="expr" type="TensorExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorExpression">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLTNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing tensor objective (if negative) or tensor constraint (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SpecialOrderedSets">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of child elements must match numberOfSOS
				</xs:documentation>
			</xs:annotation>
			<xs:element name="sos" type="SOS" minOccurs="0" maxOccurs="unbounded">
				<!--
SOS type 1 means "at most, or usually, exactly one of these variables can be nonzero (usually, in fact, 1)". This is used most commonly to model disjunctions. Type 2 means "at most two of these variables can be nonzero, and the two variables must be consecutive". This is used to model piecewise linear (typically nonconvex) functions in one variable. Tomlin used SOS to model nonconvex functions in two variables, using a triangulation of the domain. This idea can also be used for approximations in higher dimensions. In addition there may be the requirement that all the nonzero variables in an SOS must add up to 1. If present, this is called the convexity constraint. (It is the user's responsibility to add the convexity constraint to the problem.) The attribute "convexityRowIdx" can be used to identify the
convexity row to the solver, which might speed up the execution time.
-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSOS" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SOS">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="NonNegativeIntVector" minOccurs="0"/>
			<xs:element name="adjacentVariableSets" type="SOSAdjacentVariableSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Only required if type >= 3.      All nonzero variables must belong to the same adjacency set. Adjacency variable sets must be subsets of the SOS variable set.
If type = 2 adjacent variables are by default consecutive entries in the variables list.</xs:documentation>
				</xs:annotation>
				<!--
In an SOS2, adjacency usually means that nonzero variables must be consecutive within the set. They are used to model piecewise linear functions of one variable, and what is adjacent should be reasonably clear. In an SOS3 the adjacent points are the vertices of a triangle (a two-dimensional simplex), and one cannot infer the adjacency from the order of the variables in the SOS. One also cannot infer  the size of the triangulation. That's why one needs to specify adjacency lists here. Since it is possible to omit such lists for SOS2 (and certainly for SOS1), it makes sense to allow for 0 adjacencySets. (And each triangle forms its own set, hence the plural.)-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="type" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>"type = k" means at most k of the variables in this SOS can be nonzero, and the nonzeros must be "adjacent"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convexityRowIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>if present must refer to a previously defined constraint of the form 
x_i1 + x_i2 + ... = 1. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SOSAdjacentVariableSets">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="set" type="NonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of sets must match numberOfSets</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSets" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--Cones: draft -->
	<xs:complexType name="Cones">
		<xs:annotation>
			<xs:documentation>since version 2.0 </xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of various cone child elements must match numberOfCones</xs:documentation>
			</xs:annotation>
			<xs:group ref="ConeGroup"/>
		</xs:sequence>
		<xs:attribute name="numberOfCones" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:group name="ConeGroup">
		<xs:choice>
			<xs:element name="nonnegativeCone" type="NonnegativeCone"/>
			<xs:element name="nonpositiveCone" type="NonpositiveCone"/>
			<xs:element name="generalOrthantCone" type="OrthantCone"/>
			<xs:element name="polyhedralCone" type="PolyhedralCone"/>
			<xs:element name="quadraticCone" type="QuadraticCone"/>
			<xs:element name="rotatedQuadraticCone" type="RotatedQuadraticCone"/>
			<xs:element name="normedCone" type="NormedCone"/>
			<xs:element name="semidefiniteCone" type="SemidefiniteCone"/>
			<xs:element name="copositiveMatricesCone" type="CopositiveMatricesCone"/>
			<xs:element name="completelyPositiveMatricesCone" type="CompletelyPositiveMatricesCone"/>
			<xs:element name="hyperbolicityCone" type="HyperbolicityCone"/>
			<xs:element name="sumOfSquaresPolynomialsCone" type="SumOfSquaresPolynomialsCone"/>
			<xs:element name="nonnegativePolynomialsCone" type="ConeWithNonnegativePolynomials">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="momentCone" type="ConeWithNonnegativePolynomials">
				<xs:annotation>
					<xs:documentation>experiment. The cone of moments is the _dual_ of a corresponding cone of nonnegative polynomials. However, the data requirements and defining relationships are identical.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productCone" type="ProductCone"/>
			<xs:element name="intersectionCone" type="IntersectionCone"/>
			<xs:element name="dualCone" type="DualCone"/>
			<xs:element name="polarCone" type="PolarCone"/>
			<xs:element name="customCone" type="CustomCone"/>
		</xs:choice>
	</xs:group>
	<xs:complexType name="GenericCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="otherIndexes" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>use for tensors of rank >= 3. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="NonnegativeCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NonpositiveCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OrthantCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="direction" type="OrthantConeDirection" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>There must be (numberOfRows*numberOfColumns) directions (after accounting for "mult") --- similarly for higher order tensor spaces. Row index changes fastest, then column index, then other indexes.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OrthantConeDirection">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="nonnegative"/>
					<xs:enumeration value="nonpositive"/>
					<xs:enumeration value="free"/>
					<xs:enumeration value="zero"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="PolyhedralCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="direction" type="PolyhedralConeDirection" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>If present, the number of directions must correspond to the dimensions of the product Ax (after accounting for "mult"). Row index changes fastest, then column index, then other indexes.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="referenceMatrixIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="coneDirection" use="optional">
					<xs:annotation>
						<xs:documentation>"positive": Ax \ge 0; "negative": Ax \le 0; 
"mixed": specified by "direction" element</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="positive"/>
							<xs:enumeration value="negative"/>
							<xs:enumeration value="mixed"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PolyhedralConeDirection">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="nonnegative"/>
					<xs:enumeration value="nonpositive"/>
					<xs:enumeration value="free"/>
					<xs:enumeration value="zero"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="QuadraticCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="axisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>This is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RotatedQuadraticCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="firstAxisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>Each is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="secondAxisDirection" type="xs:nonNegativeInteger" use="optional" default="1"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NormedCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="axisDirectionIndex" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>index is of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="pNorm" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:minInclusive value="1.0" fixed="false"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RotatedNormedCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="firstAxisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>Each is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="secondAxisDirection" type="xs:nonNegativeInteger" use="optional" default="1"/>
				<xs:attribute name="pNorm" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:minInclusive value="1.0" fixed="false"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SemidefiniteCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="semidefiniteness" use="optional" default="positive">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="positive"/>
							<xs:enumeration value="negative"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CopositiveMatricesCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompletelyPositiveMatricesCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HyperbolicityCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:choice>
						<xs:element name="singleVariablePolynomial" type="SingleVariablePolynomial"/>
						<xs:element name="multiVariablePolynomial" type="MultiVariablePolynomial"/>
					</xs:choice>
					<xs:element name="direction" type="SparseVector">
						<xs:annotation>
							<xs:documentation>dimension of direction vector must equal the number of variables in the polynomial</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SumOfSquaresPolynomialsCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="maxDegree" default="INF">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:pattern value="[0-9]+|INF"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConeWithNonnegativePolynomials">
		<xs:annotation>
			<xs:documentation>experiment. Used for both a cone of nonnegative polynomials and its dual, a moment cone</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="upperBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>upper bounds on domain of polynomial. Default is +INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="lowerBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>lower bounds on domain of polynomial. Default is -INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="maxDegree" default="INF">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:pattern value="[0-9]+|INF"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProductCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="factors" type="NonNegativeIntVector">
						<xs:annotation>
							<xs:documentation>each factor gives the index of a previously defined cone</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IntersectionCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="components" type="NonNegativeIntVector">
						<xs:annotation>
							<xs:documentation>each component gives the index of a previously defined cone</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DualCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="referenceConeIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PolarCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="referenceConeIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CustomCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="descriptor" type="Descriptor" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RealTimeData">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation - if defaultURI is missing, this defaults to the current file.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" type="RefreshPointEnum" default="onOptimizationStart" minOccurs="0"/>
			<xs:element name="realTimeDataSource" type="RealTimeDataSource" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataSources</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataSources" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeDataSource">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>if both uri and uriAlias missing, use defaultURI</xs:documentation>
				</xs:annotation>
				<xs:element name="uri" type="xs:anyURI"/>
				<xs:element name="uriAlias" type="xs:string"/>
			</xs:choice>
			<xs:element name="dataPoint" type="RealTimeDataPoint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="refreshPoint" type="RefreshPointEnum">
			<xs:annotation>
				<xs:documentation>if missing, use value of defaultRefreshPoint</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDataPoints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeDataPoint">
		<xs:annotation>
			<xs:documentation>number must agree with numberOfDataPoints</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="sourceXPath" type="xs:string">
				<xs:annotation>
					<xs:documentation>contains a string in W3C XPath syntax. Must return a single value</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="targetComponent" type="RealTimeUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTargetComponents</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTargetComponents" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeUpdateableProblemComponent">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent"/>
			<xs:element name="implicitTree" type="UpdateableProblemComponentImplicitTree"/>
			<xs:element name="scenarioTree" type="UpdateableProblemComponentScenarioTreeProbability"/>
			<xs:element name="nodalTree" type="UpdateableProblemComponentNodalTreeProbability"/>
		</xs:choice>
		<xs:attribute name="constant" type="xs:double" default="0.0"/>
		<xs:attribute name="coef" type="xs:double" default="1.0"/>
	</xs:complexType>
	<xs:complexType name="ExternalFunctions">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" type="RefreshPointEnum" default="onInputChange" minOccurs="0"/>
			<xs:element name="externalFunction" type="ExternalFunction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfSimulations</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExternalFunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ExternalFunction">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>if both uri and uriAlias missing, use defaultURI</xs:documentation>
				</xs:annotation>
				<xs:element name="uri" type="xs:anyURI" minOccurs="0"/>
				<xs:element name="uriAlias" type="xs:nonNegativeInteger" minOccurs="0"/>
			</xs:choice>
			<xs:element name="input" type="SimulationInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="output" type="SimulationInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="numberOfInputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfOutputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="refreshPoint" type="RefreshPointEnum"/>
	</xs:complexType>
	<xs:complexType name="SimulationInputOrOutput">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="el" type="SimulationElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization.  number must agree with numberOfEl</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SimulationElement">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="real">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--Modifications: draft -->
	<xs:complexType name="InstanceModifications">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>if neither baseFile nor baseId  is supplied, it is up to the driver to decide what to do with this modification.</xs:documentation>
				</xs:annotation>
				<xs:element name="baseFile" type="ModificationBaseFile" default="this">
					<xs:annotation>
						<xs:documentation>reference to an OSiL file containing the base for the current modifications</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="baseID" type="xs:string">
					<xs:annotation>
						<xs:documentation>reference to a previous modification available in memory</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="substitutions" type="ModificationUpdates" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="ModificationDeletions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="ModificationAdditions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="refID" type="xs:string">
			<xs:annotation>
				<xs:documentation>defines a reference for subsequent reuse of this modification.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationBaseFile">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="uri" type="xs:string" use="optional" default="."/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentRealTimeDataItem">
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="uriAlias"/>
					<xs:enumeration value="uri"/>
					<xs:enumeration value="refreshPoint"/>
					<xs:enumeration value="sourceXPath"/>
					<xs:enumeration value="targetComponent"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="realTimeDataSourceIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="dataPointIdx" type="xs:nonNegativeInteger"/>
		<xs:attribute name="targetComponentIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>must be present if attr="targetComponent"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentDisjunctiveTerm">
		<xs:attribute name="disjunctionIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="disjunctiveTermIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="conditioningVariable"/>
					<xs:enumeration value="conditioningConstraint"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentDisjunctiveElement">
		<xs:attribute name="disjunctionIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="disjunctiveTermIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="elementIdx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the element within the element array of the indicated disjunctive term.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attr" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>value depends on the element type (which is inferred from the element array). E.g., if the element is a var, then possible values for attr are "lb", "ub", etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationUpdates">
		<xs:sequence>
			<xs:element name="subst" type="ModificationsUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfSubst</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationsUpdateableProblemComponent">
		<xs:choice>
			<xs:group ref="UpdateableProblemComponent"/>
			<xs:element name="implicitTree" type="UpdateableProblemComponentImplicitTree">
				<xs:annotation>
					<xs:documentation>draft - to replace one distribution in an implicit tree by another distribution with the same dimensions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarioTree" type="UpdateableProblemComponentScenarioTree">
				<xs:annotation>
					<xs:documentation>draft - to replace the probability or one stochastic value in a scenario</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodalTree" type="UpdateableProblemComponentNodalTree">
				<xs:annotation>
					<xs:documentation>draft - to replace the probability or one stochastic value in a node of a nodalTree</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveTerm" type="UpdateableProblemComponentDisjunctiveTerm"/>
			<xs:element name="disjunctiveElement" type="UpdateableProblemComponentDisjunctiveElement"/>
			<xs:element name="realTimeDataItem" type="UpdateableProblemComponentRealTimeDataItem"/>
		</xs:choice>
		<xs:attribute name="value" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>the value is read as a string and copied internally into integer, double or string types, as required by the meaning of the actual element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeletions">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DeletableProblemComponent">
				<xs:sequence minOccurs="0" maxOccurs="unbounded">
					<xs:element name="parametricAnalysis" type="ModificationDeleteParametricAnalysis" minOccurs="0"/>
					<xs:element name="disjunctions" type="ModificationDeleteDisjunctions" minOccurs="0"/>
					<xs:element name="disjunctiveTerms" type="ModificationDeleteDisjunctiveTerms" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModificationAddDisjunctiveTerm">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AppendableProblemComponent">
				<xs:attribute name="disjunctionIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModificationAdditions">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AppendableProblemComponent">
				<xs:sequence>
					<xs:element name="disjunctiveInformation" type="DisjunctiveInformation" minOccurs="0"/>
					<xs:element name="disjunctiveTerm" type="ModificationAddDisjunctiveTerm" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteVariables">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="var" type="ModificationDeleteVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a variable, its cost and constraint coefficients, and all quadratic terms and nonlinear expressions in which the variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteObjectives">
		<xs:sequence>
			<xs:element name="obj" type="ModificationDeleteObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>If present, delete only the objective coefficient in this column</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteConstraints">
		<xs:sequence>
			<xs:element name="con" type="ModificationDeleteCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="el" type="ModificationDeleteLinearConstraintEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteLinearConstraintEl">
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteQuadraticCoefficients">
		<xs:sequence>
			<xs:element name="qTerm" type="ModificationDeleteQTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteQTerm">
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>row index (constraint or objective)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>column index</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>column index</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNonlinearExpressions">
		<xs:sequence>
			<xs:element name="nl" type="ModificationDeleteNl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNl">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixVariables">
		<xs:sequence>
			<xs:element name="matrixVar" type="ModificationDeleteMatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a matrix variable and all terms in all nonlinear and matrix expressions in which the matrix variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixObjectives">
		<xs:sequence>
			<xs:element name="matrixObj" type="ModificationDeleteMatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixConstraints">
		<xs:sequence>
			<xs:element name="matrixCon" type="ModificationDeleteMatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixExpressions">
		<xs:sequence>
			<xs:element name="expr" type="ModificationDeleteMatrixExpr" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixExpr">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexVariables">
		<xs:sequence>
			<xs:element name="complexVar" type="ModificationDeleteComplexVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a complex variable and all terms in all nonlinear and complex expressions in which the complex variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexObjectives">
		<xs:sequence>
			<xs:element name="complexObj" type="ModificationDeleteComplexObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfComplexObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:int" default="-1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexConstraints">
		<xs:sequence>
			<xs:element name="complexCon" type="ModificationDeleteComplexCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfComplexCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexExpressions">
		<xs:sequence>
			<xs:element name="expr" type="ModificationDeleteComplexExpr" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteComplexExpr">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorVariables">
		<xs:sequence>
			<xs:element name="tensorVar" type="ModificationDeleteTensorVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a tensor variable and all terms in all nonlinear and tensor expressions in which the tensor variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorObjectives">
		<xs:sequence>
			<xs:element name="tensorObj" type="ModificationDeleteTensorObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfTensorObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:int" default="-1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorConstraints">
		<xs:sequence>
			<xs:element name="tensorCon" type="ModificationDeleteTensorCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfTensorCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorExpressions">
		<xs:sequence>
			<xs:element name="expr" type="ModificationDeleteTensorExpr" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteTensorExpr">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteDisjunctions">
		<xs:sequence>
			<xs:element name="disjunction" type="ModificationDeleteDisjunction" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteDisjunction">
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteDisjunctiveTerms">
		<xs:sequence>
			<xs:element name="disjunctiveTerm" type="ModificationDeleteDisjunctiveTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="disjunctionIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfDisjunctiveTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteDisjunctiveTerm">
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteRealTimeDataSource">
		<xs:attribute name="realTimeDataSourceIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="dataPointIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="targetComponentIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>if attribute is present, only replace the indicated target component. Otherwise delete all target components for the indicated data point.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteRealTimeData">
		<xs:sequence>
			<xs:element name="dataSource" type="ModificationDeleteRealTimeDataSource" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfDataSources" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteStochasticTree">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:attribute name="treeType">
			<xs:annotation>
				<xs:documentation>experiment - treeType is optional since there should be only one tree defined</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="implicit"/>
					<xs:enumeration value="scenarios"/>
					<xs:enumeration value="nodal"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteSoftConstraints">
		<xs:sequence>
			<xs:element name="con" type="ModificationDeleteSoftCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteSoftCon">
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteScenarios">
		<xs:sequence>
			<xs:element name="scen" type="ModificationDeleteScenario" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfScenarios</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfScen" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteScenario">
		<xs:attribute name="scenIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="stageIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>first stage that is to be deleted - default value: start of the scenario</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="deleteMode" default="path">
			<xs:annotation>
				<xs:documentation>delete just one scenario path (default) or the entire subtree</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="path"/>
					<xs:enumeration value="subtree"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="probAdjust" use="required">
			<xs:annotation>
				<xs:documentation>determines whether the freed probability is to be distributed among the sibling scenarios only (default if deleteMode = "path") or all remaining scenarios in the tree (default if deleteMode = "subtree").</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="siblings"/>
					<xs:enumeration value="allScenarios"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNodes">
		<xs:sequence>
			<xs:element name="node" type="ModificationDeleteNode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfNodes</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfNodes" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNode">
		<xs:attribute name="nodeId" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>Delete the referenced node and all its direct and indirect descendant; distribute the probability among the siblings of the node.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteParametricAnalysis">
		<xs:sequence>
			<xs:element name="param" type="ModificationDeleteParam" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree witih numberOfParam</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfParam" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteParam">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>experiment</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="DeletableProblemComponent">
		<xs:sequence>
			<xs:element name="variables" type="ModificationDeleteVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="ModificationDeleteObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="ModificationDeleteConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="ModificationDeleteQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationDeleteNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="ModificationDeleteMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="ModificationDeleteMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="ModificationDeleteMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationDeleteMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ModificationDeleteComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ModificationDeleteComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ModificationDeleteComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ModificationDeleteComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="ModificationDeleteTensorVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="ModificationDeleteTensorObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="ModificationDeleteTensorConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorExpressions" type="ModificationDeleteTensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="ModificationDeleteRealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticTree" type="ModificationDeleteStochasticTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - Delete the entire scenario tree or implicit tree</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="ModificationDeleteSoftConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarios" type="ModificationDeleteScenarios" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - delete one or more scenarios from a scenario tree</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodes" type="ModificationDeleteNodes" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - delete one or more nodes from a nodalTree</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AppendableProblemComponent">
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="ModificationAddObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add objective coeffficients into existing objectves</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add new objectives and their coefficients</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="ModificationAddLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationAddNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="specialOrderedSets" type="SpecialOrderedSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrices" type="Matrices" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensors" type="Tensors" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="distributions" type="Distributions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="MatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="TensorVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="TensorObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="TensorConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorExpressions" type="TensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="ModificationAddRealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticData" type="ModificationAddStochasticData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ModificationAddStochasticData">
		<xs:choice>
			<xs:element name="implicitTree" type="ImplicitTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - can only add if there is no tree currently defined</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarioTree" type="ScenarioTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - can only add if there is no tree currently defined</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarios" type="ModificationAddScenarios" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - add one or more scenarios to an existing scenario tree</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodalTree" type="NodalTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - can only add if there is no tree currently defined</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodalSubtrees" type="ModificationAddNodalSubtrees" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - add subtrees to an existing nodalTree</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ModificationAddNodalSubtrees">
		<xs:sequence>
			<xs:element name="subtree" type="NodalSubtree" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfSubtrees</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSubtrees" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalSubtree">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="rootNode" type="NodalSubtreeRootNode">
				<xs:annotation>
					<xs:documentation>defines the root node
of the subtree</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalSubtreeRootNode">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="sNode">
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="parentNodeID" type="xs:IDREF" use="required">
					<xs:annotation>
						<xs:documentation>must be present to identify location of the subtree root</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="numberOfLinkingStages" type="xs:nonNegativeInteger" default="1">
					<xs:annotation>
						<xs:documentation>governs the length of the history that can influence the present node as well as the offsets for variable and constraint references</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModificationAddObjectiveCoefficients">
		<xs:sequence>
			<xs:element name="obj" type="ModificationAddObjective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddObjective">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number of coef child elements must match numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>If idx is repeated, the objective terms/coefficients are added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>must refer to a previously existing objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="el" type="ModificationAddLinearConstraintCoefficientsEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddLinearConstraintCoefficientsEl">
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="value" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddNonlinearExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="nl" type="Nl"/>
		</xs:choice>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="MatrixExpression"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="ComplexExpression"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddTensorExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="TensorExpression"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddRealTimeData">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="realTimeDataSource" type="RealTimeDataSource" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataSources</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataSources" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddScenarios">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="scenario" type="Scenario" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfScenarios</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfScenarios" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctiveSet">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of alternatives must agree with numberOfAlternatives</xs:documentation>
			</xs:annotation>
			<xs:element name="disjunctiveTerm" type="DisjunctiveModifications" minOccurs="2" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>different disjunctive terms are connected by logical OR</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctiveTerms" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>may be overridden by information in the multilevelAndStochasticProgramming section</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DisjunctiveInformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of disjunctions must agree with numberOfDisjunctions</xs:documentation>
			</xs:annotation>
			<xs:element name="conditioningVariables" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to identify logical core variables that describe conditions under which one of the disjunctions holds</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="conditioningConstraints" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to identify core constraints that describe additional restrictions on the logical conditioningVariables</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunction" type="DisjunctiveSet" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>different disjunctive sets are connected by logical AND.
If the problem exhibits time structure, especially stochastic structure, then a disjunction can be associated with a time stage. (See "timeStages" element.)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionUpdates">
		<xs:sequence>
			<xs:element name="subst" type="DisjunctionUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfSubst</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionUpdateableProblemComponent">
		<xs:choice>
			<xs:group ref="UpdateableProblemComponent"/>
			<xs:element name="implicitTree" type="UpdateableProblemComponentImplicitTree">
				<xs:annotation>
					<xs:documentation>draft - to replace one distribution in an implicit tree by another distribution with the same dimensions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarioTree" type="UpdateableProblemComponentScenarioTree">
				<xs:annotation>
					<xs:documentation>draft - to replace the probability or one stochastic value in a scenario</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodalTree" type="UpdateableProblemComponentNodalTree">
				<xs:annotation>
					<xs:documentation>draft - to replace the probability or one stochastic value in a node of a nodalTree</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeDataItem" type="UpdateableProblemComponentRealTimeDataItem"/>
		</xs:choice>
		<xs:attribute name="value" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>the value is read as a string  and copied internally into integer, double or string types, as required by the meaning of the actual element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DisjunctionDeletions">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DeletableProblemComponent">
				<xs:sequence>
					<xs:element name="parametricAnalysis" type="ModificationDeleteParametricAnalysis" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DisjunctiveModifications">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="substitutions" type="DisjunctionUpdates" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="DisjunctionDeletions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="AppendableProblemComponent" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="conditioningVariableIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>disjunction is enforced only if logical conditioning variable is TRUE</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conditioningConstraintIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>disjunction is enforced only if logical conditioning constraint is TRUE</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--Parametric analysis: draft-->
	<xs:complexType name="ParametricAnalysis">
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the param child elements must agree with numberOfParam</xs:documentation>
			</xs:annotation>
			<xs:element name="param" type="Param" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfParam" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Distributions">
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the dist child elements must agree with numberOfDist</xs:documentation>
			</xs:annotation>
			<xs:element name="dist" type="StochasticDistribution" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDist" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentVariable">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="type"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentObjective">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="weight"/>
					<xs:enumeration value="coef"/>
					<xs:enumeration value="maxOrMin"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="varIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>required if attr="coef"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentConstraint">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentLinearConstraintCoefficient">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentQuadraticCoefficient">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:int" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>refers to an OSnLNode given an ID in the core section</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlCNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required"/>
		<xs:attribute name="part" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="real"/>
					<xs:enumeration value="imaginary"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlMNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>identifies the OSnLMNode in the nonlinear expression trees</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlTNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>identifies the OSnLTNode in the nonlinear expression trees</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentMatrixElement">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="matrixIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="realOrImaginary" default="real">
			<xs:annotation>
				<xs:documentation>to access either the real or the imaginary part of a complex number</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="real"/>
					<xs:enumeration value="imaginary"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentTensorElement">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="dimensions" type="PositiveIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>number of elements in dimensions vector must equal tensor rank. Dimensions may be omitted if rank=0.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="tensorIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="realOrImaginary" default="real">
			<xs:annotation>
				<xs:documentation>to access either the real or the imaginary part of a complex number</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="real"/>
					<xs:enumeration value="imaginary"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentMatrixVariable">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbMatrixIdx"/>
					<xs:enumeration value="ubMatrixIdx"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentMatrixObjective">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="orderConeIdx"/>
					<xs:enumeration value="constantMatrixIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentMatrixConstraint">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbMatrixIdx"/>
					<xs:enumeration value="ubMatrixIdx"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentComplexVariable">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbRealPart"/>
					<xs:enumeration value="lbImaginaryPart"/>
					<xs:enumeration value="ubRealPart"/>
					<xs:enumeration value="ubImaginaryPart"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentComplexObjective">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="orderConeIdx"/>
					<xs:enumeration value="additiveConstantRealPart"/>
					<xs:enumeration value="additiveConstantImaginaryPart"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentComplexConstraint">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbRealPart"/>
					<xs:enumeration value="lbImaginaryPart"/>
					<xs:enumeration value="ubRealPart"/>
					<xs:enumeration value="ubImaginaryPart"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentTensorVariable">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbTensorIdx"/>
					<xs:enumeration value="ubTensordx"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentTensorObjective">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="orderConeIdx"/>
					<xs:enumeration value="constantTensorIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentTensorConstraint">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lbTensordx"/>
					<xs:enumeration value="ubTensorIdx"/>
					<xs:enumeration value="lbConeIdx"/>
					<xs:enumeration value="ubConeIdx"/>
					<xs:enumeration value="name"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentImplicitTree">
		<xs:annotation>
			<xs:documentation>draft - to replace one distribution in an implicit tree by another distribution with the same dimensions</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rvIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="distribution"/>
					<xs:enumeration value="transformationMatrix"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="distributionIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>required if attr="distribution"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="transformationMatrixIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>required if attr="transformationMatrix"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentScenarioTree">
		<xs:annotation>
			<xs:documentation>draft - to replace the probability or one stochastic value in a scenario</xs:documentation>
		</xs:annotation>
		<xs:attribute name="scenarioIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="prob"/>
					<xs:enumeration value="element"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="probType">
			<xs:annotation>
				<xs:documentation>path probability or conditional probability - default is "path"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="path"/>
					<xs:enumeration value="cond"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="elementIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>must be present if attr="element"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentScenarioTreeProbability">
		<xs:annotation>
			<xs:documentation>draft - to replace the probability of a scenario</xs:documentation>
		</xs:annotation>
		<xs:attribute name="scenarioIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="probType">
			<xs:annotation>
				<xs:documentation>path probability or conditional probability - default is "path"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="path"/>
					<xs:enumeration value="cond"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentScenarioTreeElement">
		<xs:annotation>
			<xs:documentation>draft - to parametrize one stochastic value in a scenario</xs:documentation>
		</xs:annotation>
		<xs:attribute name="scenarioIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="elementIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNodalTree">
		<xs:attribute name="nodeId" type="xs:IDREF" use="required"/>
		<xs:attribute name="component" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>"prob", "var", etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attr" type="xs:string">
			<xs:annotation>
				<xs:documentation>if component is not "prob", this attribute is required to pinpoint where the value is to be stored (e.g., if component="var", attr could be "lb", "ub", etc.)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>if component is not "prob", this attribute is required to identify the array element (e.g., variable number) where the value is to be stored.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNodalTreeProbability">
		<xs:annotation>
			<xs:documentation>draft - to replace the probability of a scenario</xs:documentation>
		</xs:annotation>
		<xs:attribute name="nodeId" type="xs:IDREF" use="required"/>
		<xs:attribute name="probType">
			<xs:annotation>
				<xs:documentation>path probability or conditional probability - default is "path"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="path"/>
					<xs:enumeration value="cond"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNodalTreeElement">
		<xs:attribute name="nodeId" type="xs:IDREF" use="required"/>
		<xs:attribute name="component" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>"var", "obj", etc.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifyies the array element (e.g., variable number) where the value is to be stored.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attr" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>needed to pinpoint where the value is to be stored (e.g., if component="var", attr could be "lb", "ub", etc.)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentDistributionParameter">
		<xs:attribute name="distribIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>value must match one of the attribute names in the corresponding distribution, e.g., "mean".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>used to identify an element within a one-dimensional array of parameters, e.g., mean of multivariateNormal.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentLinearOrQuadraticPenalty">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index within the array of softConstraint objects</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attr" use="required">
			<xs:annotation>
				<xs:documentation>allowable attribute values depend on the type of soft constraint; e.g., for simple recourse, possible values are "surplusPenalty" and "shortage Penalty".</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="shortagePenalty"/>
					<xs:enumeration value="surplusPenalty"/>
					<xs:enumeration value="linearShortageParam"/>
					<xs:enumeration value="linearSurplusParam"/>
					<xs:enumeration value="quadraticShortageParam"/>
					<xs:enumeration value="quadraticSurplusParam"/>
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="aggregatingFunction"/>
					<xs:enumeration value="maxOrMin"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:group name="UpdateableProblemComponentMatrixProgrammingGroup">
		<xs:choice>
			<xs:element name="matrixVar" type="UpdateableProblemComponentMatrixVariable"/>
			<xs:element name="matrixObj" type="UpdateableProblemComponentMatrixObjective"/>
			<xs:element name="matrixCon" type="UpdateableProblemComponentMatrixConstraint"/>
			<xs:element name="OSnLMNode" type="UpdateableProblemComponentNlMNode"/>
		</xs:choice>
	</xs:group>
	<xs:group name="UpdateableProblemComponentComplexProgrammingGroup">
		<xs:choice>
			<xs:element name="complexVar" type="UpdateableProblemComponentComplexVariable"/>
			<xs:element name="complexObj" type="UpdateableProblemComponentComplexObjective"/>
			<xs:element name="complexCon" type="UpdateableProblemComponentComplexConstraint"/>
			<xs:element name="OSnLCNode" type="UpdateableProblemComponentNlCNode"/>
		</xs:choice>
	</xs:group>
	<xs:group name="UpdateableProblemComponentTensorProgrammingGroup">
		<xs:choice>
			<xs:element name="tensorVar" type="UpdateableProblemComponentTensorVariable"/>
			<xs:element name="tensorObj" type="UpdateableProblemComponentTensorObjective"/>
			<xs:element name="tensorCon" type="UpdateableProblemComponentTensorConstraint"/>
			<xs:element name="OSnLTNode" type="UpdateableProblemComponentNlTNode"/>
		</xs:choice>
	</xs:group>
	<xs:group name="UpdateableProblemComponent">
		<xs:choice>
			<xs:element name="var" type="UpdateableProblemComponentVariable">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="obj" type="UpdateableProblemComponentObjective">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the objective</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="con" type="UpdateableProblemComponentConstraint">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficient" type="UpdateableProblemComponentLinearConstraintCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the constraint matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="qCoef" type="UpdateableProblemComponentQuadraticCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the quadratic expressions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OSnLNode" type="UpdateableProblemComponentNlNode">
				<xs:annotation>
					<xs:documentation>draft - refer to any OSnLNode in any nonlinear expression, including matrix constructs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixElement" type="UpdateableProblemComponentMatrixElement">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorElement" type="UpdateableProblemComponentTensorElement">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="distributionParameter" type="UpdateableProblemComponentDistributionParameter"/>
			<xs:element name="matrixVar" type="UpdateableProblemComponentMatrixVariable"/>
			<xs:element name="matrixObj" type="UpdateableProblemComponentMatrixObjective"/>
			<xs:element name="matrixCon" type="UpdateableProblemComponentMatrixConstraint"/>
			<xs:element name="OSnLMNode" type="UpdateableProblemComponentNlMNode"/>
			<xs:element name="complexVar" type="UpdateableProblemComponentComplexVariable"/>
			<xs:element name="complexObj" type="UpdateableProblemComponentComplexObjective"/>
			<xs:element name="complexCon" type="UpdateableProblemComponentComplexConstraint"/>
			<xs:element name="OSnLCNode" type="UpdateableProblemComponentNlCNode"/>
			<xs:element name="tensorVar" type="UpdateableProblemComponentTensorVariable"/>
			<xs:element name="tensorObj" type="UpdateableProblemComponentTensorObjective"/>
			<xs:element name="tensorCon" type="UpdateableProblemComponentTensorConstraint"/>
			<xs:element name="OSnLTNode" type="UpdateableProblemComponentNlTNode"/>
			<xs:element name="softConstraintOrObjective" type="UpdateableProblemComponentLinearOrQuadraticPenalty"/>
		</xs:choice>
	</xs:group>
	<xs:complexType name="Param">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent"/>
			<xs:element name="scenarioTreeElement" type="UpdateableProblemComponentScenarioTreeElement"/>
			<xs:element name="nodalTreeElement" type="UpdateableProblemComponentNodalTreeElement"/>
		</xs:choice>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="type" type="GeneralEnumerationVarType" use="optional" default="C"/>
		<xs:attribute name="incr" type="xs:double">
			<xs:annotation>
				<xs:documentation>default is (ub-lb)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" use="optional"/>
	</xs:complexType>
	<!--RealTimeData: recommendation-->
	<xs:complexType name="RealTimeDataURI">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:anyURI">
				<xs:attribute name="alias" type="xs:string" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="RealTimeDataURIAliases">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the url child elements must agree with numberOfURIAliases</xs:documentation>
			</xs:annotation>
			<xs:element name="uri" type="RealTimeDataURI" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfURIAliases" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStages">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of stages must agree with numberOfStages</xs:documentation>
			</xs:annotation>
			<xs:element name="stage" type="TimeStageOrLevel" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfStages" type="xs:positiveInteger" use="required"/>
		<xs:attribute name="eventsFollowDecisions" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>events and decisions, constraints, disjunctions, etc. can share a stage. By default events precede all decisions, etc. in a stage. This attribute can be used to reverse the order. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageOrLevel">
		<xs:annotation>
			<xs:documentation>proposal - for use in both stochastic programming and multilevel programming</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="TimeStageVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="TimeStageObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="TimeStageConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctions" type="TimeStageDisjunctions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume numberOfDisjunctions=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="TimeStageMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="TimeStageMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="TimeStageMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="TimeStageComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="TimeStageComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="TimeStageComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="TimeStageTensorVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="TimeStageTensorObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="TimeStageTensorConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeStageVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="var" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfVar after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfCon after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageDisjunctions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="disjunction" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDisjunctions after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="obj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree witih numberOfObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="matrixVar" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree witih numberOfMatrixVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="matrixCon" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfMatrixCon after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="matrixObj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfMatrixObj after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="var" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfVar after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfCon after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="obj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfObj after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="tensorVar" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTensorVar after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="tensorCon" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTensorCon after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorObjectives">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="tensorObj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTensorObj after "mult" has been considered.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--StochasticInformation: proposal-->
	<xs:complexType name="StochasticDistribution">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:group ref="DistributionGroup"/>
			<xs:group ref="DistributionTransformationGroup"/>
			<xs:element ref="custom"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="StochasticElements">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number must agree with numberOfStochEl</xs:documentation>
			</xs:annotation>
			<xs:group ref="UpdateableProblemComponent"/>
		</xs:choice>
		<xs:attribute name="numberOfStochEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!-- A new way of looking at stochastics by building on existing constructs -->
	<xs:complexType name="StochasticDataModifications">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="nodalTree" type="NodalTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ScenarioTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="scenario" type="Scenario" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfScenarios</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfScenarios" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mode" default="replace">
			<xs:annotation>
				<xs:documentation>scenario values can replace deterministic base values, or can be given as additive or multiplicative modifications </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="replace"/>
					<xs:enumeration value="add"/>
					<xs:enumeration value="multiply"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ChangesInScenario">
		<xs:sequence>
			<xs:element name="idx" type="SizelessNonNegativeIntVector">
				<xs:annotation>
					<xs:documentation>index refers to location within the list of stochastic elements. Size of vector must agree with numberOfChanges</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="value" type="SizelessDoubleVector">
				<xs:annotation>
					<xs:documentation>size of vector must agree with numberOfChanges</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Scenario">
		<xs:sequence>
			<xs:element name="changesFromBase" type="ChangesInScenario" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="parentIdx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>gives the index of the parent scenario. The root scenario has parentIdx = -1.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="prob" use="required">
			<xs:annotation>
				<xs:documentation>scenario probability</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:double">
					<xs:minInclusive value="0"/>
					<xs:maxInclusive value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="probType">
			<xs:annotation>
				<xs:documentation>path probability or conditional probability - default is "path"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="path"/>
					<xs:enumeration value="cond"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="baseIdx" type="xs:int">
			<xs:annotation>
				<xs:documentation>gives the index of a scenario that contains the default data. The default value is parentIdx; use -1 to indicate the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>gives the first stage in which this scenario has data that differ from its parent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfChanges" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>changes are relative to parent or, if present, the base scenario</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="NodalTree">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="rootNode" type="RootNode"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RootNode">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="sNode">
				<xs:attribute name="prob" type="Probability" use="optional" default="1"/>
				<xs:attribute name="useCoreData" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>must be present if nodeData element is missing; if useCoreData is TRUE, ignore nodeData if present</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticNode">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="sNode">
				<xs:attribute name="prob" type="Probability" use="required">
					<xs:annotation>
						<xs:documentation>This is the conditional probability of reaching this node given its parent node.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="numberOfLinkingStages" type="xs:nonNegativeInteger" default="1">
					<xs:annotation>
						<xs:documentation>governs the length of the history that can influence the present node as well as the offsets for variable and constraint references</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="sNode" mixed="false">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element name="nodeData" type="NodeData">
					<xs:annotation>
						<xs:documentation>nodal trees use local indexing for variables and constraints. To refer to variables or constraints in past tree nodes use the attribute "lag".
Experiment.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="modifications" type="NodeModifications"/>
			</xs:choice>
			<xs:element name="sNode" type="StochasticNode" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="nodeID" type="xs:ID">
			<xs:annotation>
				<xs:documentation>used to provide a reference for later inheritance of data</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="scenarioNode" type="sNode" abstract="true">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="NodeData">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the variables in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="NodalTreeObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to add objective coefficients for variables in the currrent node into previously defined objectives</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additionalObjectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>the indexing is cumulative. additional objectives are added below the indices of previously defined objectives.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the constraints in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="NodalTreeLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>includes matrices on and below the diagonal. Variable indices are offset by the variables in the linking ancestor nodes</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="NodalTreeQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0 - Does not use matrices. So, e.g., the expression 4x + 5y + x^2 + 2xy + 3y^2 has three quadratic coefficients: 1, 2, 3</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NodalTreeNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the expressions in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="specialOrderedSets" type="NodalTreeSpecialOrderedSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0
We use the LPSOLVE definition of SOS, which goes back to a paper by J.A.Tomlin in "Studies on Graphs and Discrete Programming", 1981. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixProgramming" type="NodalTreeMatrixProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0. The indexing is cumulative; current node indices are added after the indices of the ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexProgramming" type="NodalTreeComplexProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorProgramming" type="NodalTreeTensorProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0. The indexing is cumulative; current node indices are added after the indices of the ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveInformation" type="DisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticData" type="StochasticDataModifications" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeObjectiveCoefficients">
		<xs:sequence>
			<xs:element name="obj" type="NodalTreeObjective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeObjective">
		<xs:sequence>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" default="-1"/>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms </xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="NodalTreeQuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeQuadraticTerm">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of the constraint or objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxLag" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxStage" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxNode" type="xs:IDREF">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the first variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneLag" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneStage" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneNode" type="xs:IDREF">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the second variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoType" type="NodalTreeIndexType" use="optional" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoLag" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoStage" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoNode" type="xs:IDREF">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1">
			<xs:annotation>
				<xs:documentation>coefficient of the
quadratic term</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="block" type="NodalTreeLinearConstraintCoefficientBlock" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeLinearConstraintCoefficientBlock">
		<xs:complexContent>
			<xs:extension base="LinearConstraintCoefficients">
				<xs:attribute name="varRefType" type="NodalTreeIndexType" use="optional" default="local">
					<xs:annotation>
						<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="varRefLag" type="xs:nonNegativeInteger" use="optional">
					<xs:annotation>
						<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="varRefStage" type="xs:nonNegativeInteger" use="optional">
					<xs:annotation>
						<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="varRefNode" type="xs:IDREF" use="optional">
					<xs:annotation>
						<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="conRefType" type="NodalTreeIndexType" use="optional" default="local">
					<xs:annotation>
						<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="conRefLag" type="xs:nonNegativeInteger" use="optional">
					<xs:annotation>
						<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="conRefStage" type="xs:nonNegativeInteger" use="optional">
					<xs:annotation>
						<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="conRefNode" type="xs:IDREF" use="optional">
					<xs:annotation>
						<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the child nl elements must agree with numberOfNonlinearExpressions</xs:documentation>
			</xs:annotation>
			<xs:element name="nl" type="NodalTreeNl" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>shape attribute added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfNonlinearExpressions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeNl">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of constraint or objective row</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" use="optional" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxLag" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the lag of this row if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxStage" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this row if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxNode" type="xs:IDREF" use="optional">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="unknown">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="concave"/>
					<xs:enumeration value="general"/>
					<xs:enumeration value="unknown"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeSpecialOrderedSets">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of child elements must match numberOfSOS
				</xs:documentation>
			</xs:annotation>
			<xs:element name="sos" type="NodalTreeSOS" minOccurs="0" maxOccurs="unbounded">
				<!--
SOS type 1 means "at most, or usually, exactly one of these variables can be nonzero (usually, in fact, 1)". This is used most commonly to model disjunctions. Type 2 means "at most two of these variables can be nonzero, and the two variables must be consecutive". This is used to model piecewise linear (typically nonconvex) functions in one variable. Tomlin used SOS to model nonconvex functions in two variables, using a triangulation of the domain. This idea can also be used for approximations in higher dimensions. In addition there may be the requirement that all the nonzero variables in an SOS must add up to 1. If present, this is called the convexity constraint. (It is the user's responsibility to add the convexity constraint to the problem.) The attribute "convexityRowIdx" can be used to identify the
convexity row to the solver, which might speed up the execution time.
-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSOS" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeSOS">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="NodalTreeSOSIntVector" minOccurs="0"/>
			<xs:element name="adjacentVariableSets" type="NodalTreeSOSAdjacentVariableSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Only required if type >= 3.      All nonzero variables must belong to the same adjacency set. Adjacency variable sets must be subsets of the SOS variable set.
If type = 2 adjacent variables are by default consecutive entries in the variables list.</xs:documentation>
				</xs:annotation>
				<!--
In an SOS2, adjacency usually means that nonzero variables must be consecutive within the set. They are used to model piecewise linear functions of one variable, and what is adjacent should be reasonably clear. In an SOS3 the adjacent points are the vertices of a triangle (a two-dimensional simplex), and one cannot infer the adjacency from the order of the variables in the SOS. One also cannot infer  the size of the triangulation. That's why one needs to specify adjacency lists here. Since it is possible to omit such lists for SOS2 (and certainly for SOS1), it makes sense to allow for 0 adjacencySets. (And each triangle forms its own set, hence the plural.)-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="type" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>"type = k" means at most k of the variables in this SOS can be nonzero, and the nonzeros must be "adjacent"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convexityRowIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>if present must refer to a previously defined constraint of the form 
x_i1 + x_i2 + ... = 1. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeSOSAdjacentVariableSets">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="set" type="NonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of sets must match numberOfSets.  Elements of each set are indices that refer back to the list of variables in the SOS, that is, each value must be less than the number of elements in the variables - el vector.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSets" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeMatrixProgramming">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0"/>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>As scalar objectives,  additional matrix objectives are added below the indices of previously defined matrix objectives.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0"/>
			<xs:element name="matrixExpressions" type="NodalTreeMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For matrix-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeMatrixExpressions">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="NodalTreeMatrixExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeMatrixExpression">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLMNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing matrix objective (if negative) or matrix constraint (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" use="optional" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxLag" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the lag of this matrix constraint or variable if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxStage" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this matrix constraint or variable if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxNode" type="xs:IDREF" use="optional">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeComplexProgramming">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0"/>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0"/>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0"/>
			<xs:element name="complexExpressions" type="NodalTreeComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For complex-valued expressions only - real-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeComplexExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="NodalTreeComplexExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeComplexExpression">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing complex objectives (if negative) or complex constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" use="optional" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxLag" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the lag of this complex constraint or variable if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxStage" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this complex constraint or variable if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxNode" type="xs:IDREF" use="optional">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeTensorProgramming">
		<xs:annotation>
			<xs:documentation>experiment--</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="tensorVariables" type="TensorVariables" minOccurs="0"/>
			<xs:element name="tensorObjectives" type="TensorObjectives" minOccurs="0"/>
			<xs:element name="tensorConstraints" type="TensorConstraints" minOccurs="0"/>
			<xs:element name="tensorExpressions" type="NodalTreeTensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For tensor-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeTensorExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="NodalTreeTensorExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeTensorExpression">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing tensor objectives (if negative) or tensor constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" use="optional" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxLag" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the lag of this tensor constraint or variable if  idxType="lag"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxStage" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Gives the stage number of this tensor constraint or variable if idxType="stage"; ignored otherwise</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxNode" type="xs:IDREF" use="optional">
			<xs:annotation>
				<xs:documentation>Gives a reference to another node in the tree if idxType="node"; ignored otherwise.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodeModifications">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="substitutions" type="NodalTreeModificationUpdates" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="NodalTreeModificationDeletions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="NodalTreeModificationAdditions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="baseRef" type="xs:IDREF">
			<xs:annotation>
				<xs:documentation>used to identify another node in the tree as a base from which the current node inherits data</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponent">
		<xs:choice>
			<xs:element name="var" type="UpdateableProblemComponentVariable">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="obj" type="UpdateableProblemComponentObjective">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the objective</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="con" type="UpdateableProblemComponentConstraint">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficient" type="NodalTreeUpdateableProblemComponentLinearConstraintCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the constraint matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="qCoef" type="NodalTreeUpdateableProblemComponentQuadraticCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the quadratic expressions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OSnLNode" type="UpdateableProblemComponentNlNode">
				<xs:annotation>
					<xs:documentation>draft - refer to any OSnLNode in any nonlinear expression, including matrix constructs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVar" type="UpdateableProblemComponentMatrixVariable"/>
			<xs:element name="matrixObj" type="UpdateableProblemComponentMatrixObjective"/>
			<xs:element name="matrixCon" type="UpdateableProblemComponentMatrixConstraint"/>
			<xs:element name="OSnLMNode" type="UpdateableProblemComponentNlMNode"/>
			<xs:element name="complexVar" type="UpdateableProblemComponentComplexVariable"/>
			<xs:element name="complexObj" type="UpdateableProblemComponentComplexObjective"/>
			<xs:element name="complexCon" type="UpdateableProblemComponentComplexConstraint"/>
			<xs:element name="OSnLCNode" type="UpdateableProblemComponentNlCNode"/>
			<xs:element name="tensorVar" type="UpdateableProblemComponentTensorVariable"/>
			<xs:element name="tensorObj" type="UpdateableProblemComponentTensorObjective"/>
			<xs:element name="tensorCon" type="UpdateableProblemComponentTensorConstraint"/>
			<xs:element name="OSnLTNode" type="UpdateableProblemComponentNlTNode"/>
			<xs:element name="realTimeData" type="UpdateableProblemComponentRealTimeDataItem"/>
		</xs:choice>
		<xs:attribute name="value" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>the value is read as a string  and copied internally into integer, double or string types, as required by the meaning of the actual element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationUpdates">
		<xs:sequence>
			<xs:element name="subst" type="NodalUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeUpdateableProblemComponentLinearConstraintCoefficient">
		<xs:complexContent>
			<xs:extension base="UpdateableProblemComponentLinearConstraintCoefficient">
				<xs:attribute name="blockIdx" type="xs:nonNegativeInteger" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeUpdateableProblemComponentQuadraticCoefficient">
		<xs:complexContent>
			<xs:extension base="UpdateableProblemComponentQuadraticCoefficient">
				<xs:attribute name="rowIdxType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="rowIdxModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxOneType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxOneModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxTwoType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxTwoModifier" type="xs:nonNegativeInteger" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeletions">
		<xs:sequence>
			<xs:element name="variables" type="ModificationDeleteVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="ModificationDeleteObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="ModificationDeleteConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintBlocks" type="NodalTreeModificationDeleteLinearConstraintBlocks" minOccurs="0"/>
			<xs:element name="linearConstraintCoefficients" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="ModificationDeleteQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationDeleteNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="ModificationDeleteMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="ModificationDeleteMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="ModificationDeleteMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationDeleteMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ModificationDeleteComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ModificationDeleteComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ModificationDeleteComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ModificationDeleteComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="ModificationDeleteTensorVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="ModificationDeleteTensorObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="ModificationDeleteTensorConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorExpressions" type="ModificationDeleteTensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="ModificationDeleteRealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctions" type="ModificationDeleteDisjunctions" minOccurs="0"/>
			<xs:element name="disjunctiveTerms" type="ModificationDeleteDisjunctiveTerms" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteLinearConstraintBlocks">
		<xs:sequence>
			<xs:element name="block" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAdditions">
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="ModificationAddObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add objective coeffficients into existing objectives</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add new objectives and their coefficients</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="NodalTreeModificationAddLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment
To add coefficients one at a time</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintBlocks" type="NodalTreeModificationAddLinearConstraintBlocks" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment
To add entire coefficient blocks more efficiently</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationAddNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationAddMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ModificationAddComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="TensorVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="TensorObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="TensorConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorExpressions" type="ModificationAddTensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="el" type="NodalTreeModificationAddLinearConstraintEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintEl">
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="blockIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="value" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintBlocks">
		<xs:sequence>
			<xs:element name="block" type="NodalTreeLinearConstraintCoefficientBlock" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ImplicitTree">
		<xs:sequence>
			<xs:element name="rv" type="ImplicitTreeBlock" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfRV. Each random variable or vector is
referenced by distributionIdx and is independent of all other rv's.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="SoftConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal - use for penalties, chance constraints and probabilistic objectives.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfRV" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="ambiguityResolution">
			<xs:annotation>
				<xs:documentation>default is "max" for minimization problems, "min" for maximization problems</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="any"/>
					<xs:enumeration value="all"/>
					<xs:enumeration value="avg"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="min"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImplicitTreeLinearTransformation">
		<xs:sequence>
			<xs:element name="ar" type="AutoRegressiveTerm" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Autoregressive terms. Number must agree with numberOfAR. 
Each term refers to the value(s) of a previously defined random variable and appends one or more rows to the input vector for the linear transformation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ma" type="MovingAveragesTerm" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Moving average terms. Number must agree with numberOfMA. Each term refers to the value of a previously set stochastic element and apppends one row to the input vector for the linear transformation.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMA" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>moving average terms</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfAR" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>autoregressive terms</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the matrix defining the linear transformation.
</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="addConstant" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation> Default is "false".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImplicitTreeBlock">
		<xs:sequence>
			<xs:element name="stochasticLocations" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>refers back to the list of stochastic elements established previously</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>if neither linear nor nonlinear transformation is specified, the default is linear with an identity matrix of appropriate dimension.</xs:documentation>
				</xs:annotation>
				<xs:element name="linearTransformation" type="ImplicitTreeLinearTransformation" minOccurs="0">
					<xs:annotation>
						<xs:documentation>A matrix must have constant matrix elements.
number of rows = number of stochastic elements.
columns are determined by the sequence of elements of the rv, all AR terms, MA terms, plus a '1' if addConstant ="true".
</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="nonlinearTransformation" type="ImplicitTreeNonlinearTransformation" minOccurs="0">
					<xs:annotation>
						<xs:documentation>the transformation forms a flattened column vector of current observations and autoregressive terms and moving average terms (and perhaps a constant term at the very end) and transforms this into the vector of stochastic elements. 
Default: identity matrix.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="stageIdx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>number of the stage in which the information is revealed</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distributionIdx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>gives the index of the distribution in the "distributions" element</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImplicitTreeNonlinearTransformation">
		<xs:choice minOccurs="0">
			<xs:element name="userFunction" type="OSnLMNodeUserF">
				<xs:annotation>
					<xs:documentation>must return a column vector of dimension equal to the number of stochastic elements.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="AutoRegressiveTerm">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>gives the index (and hence locations and values) of a previously defined RV</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="MovingAveragesTerm">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>references the untransformed value of a previously defined RV</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:group name="SingleSoftConstraintGroup">
		<xs:choice>
			<xs:element name="linearPenalty" type="SoftConstraintsSimpleRecourse"/>
			<xs:element name="quadraticPenalty" type="SoftConstraintsQuadraticPenalty"/>
			<xs:element name="userDefinedPenalty" type="SoftConstraintsUserDefinedPenalty"/>
			<xs:element name="chanceConstraint" type="SoftConstraintsSimpleChanceConstraint"/>
			<xs:element name="integratedChanceConstraint" type="SoftConstraintsSimpleIntegratedChanceConstraint"/>
			<xs:element name="probabilisticObjective" type="SoftConstraintsSimpleProbabilisticObjective"/>
		</xs:choice>
	</xs:group>
	<xs:group name="JointSoftConstraintGroup">
		<xs:choice>
			<xs:element name="jointChanceConstraint" type="SoftConstraintsJointChanceConstraint"/>
			<xs:element name="jointUserDefinedPenalty" type="SoftConstraintsJointUserDefinedPenalty"/>
			<xs:element name="jointProbabilisticObjective" type="SoftConstraintsJointProbabilisticObjective"/>
		</xs:choice>
	</xs:group>
	<xs:complexType name="SoftConstraintsPenaltiesRow">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:group ref="SingleSoftConstraintGroup"/>
			<xs:group ref="JointSoftConstraintGroup"/>
			<xs:element name="userDefinedLossFunction" type="SoftConstraintsUserDefinedPenaltyFunction" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment - use for arbitrary loss functions f(x,w)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="objectiveIdx" type="xs:negativeInteger" use="optional" default="-1">
			<xs:annotation>
				<xs:documentation>objective to which the term is to be added; default is -1</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleRecourse">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the row to be penalized</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shortagePenalty" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="surplusPenalty" type="xs:double" use="optional" default="0"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsQuadraticPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the row to be penalized</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="linearShortageParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="linearSurplusParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticShortageParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticSurplusParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="piecewiseLinearQuadratic" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>if true, sets up Rockafellar's piecewise linear-quadratic penalties</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="surplusPenalty" type="SoftConstraintsUserDefinedPenaltyFunction" minOccurs="0">
				<xs:annotation>
					<xs:documentation>penalty term added if constraint body exceeds upper bound</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="shortagePenalty" type="SoftConstraintsUserDefinedShortagePenalty" minOccurs="0">
				<xs:annotation>
					<xs:documentation>penalty term added if constraint body falls below lower bound</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the constraint to be penalized</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedPenaltyFunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedShortagePenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleProbabilisticObjective">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the constraint</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constraintType">
			<xs:annotation>
				<xs:documentation>type of constraint; 
default is "scalar"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="scalar"/>
					<xs:enumeration value="matrix"/>
					<xs:enumeration value="complex"/>
					<xs:enumeration value="tensor"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="maxOrMin" default="max">
			<xs:annotation>
				<xs:documentation>maximize or minimize the probability of constraint satisfaction; default is "max"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointProbabilisticObjective">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="con" type="SoftConstraintsJointProbabiliticObjectiveRow" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must equal numberOfCon</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="maxOrMin" default="max">
			<xs:annotation>
				<xs:documentation>maximize or minimize the probability of constraint satisfaction; default is "max"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointProbabiliticObjectiveRow">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="constraintType">
			<xs:annotation>
				<xs:documentation>type of constraint; 
default is "scalar"</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="scalar"/>
					<xs:enumeration value="matrix"/>
					<xs:enumeration value="complex"/>
					<xs:enumeration value="tensor"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the row to be penalized</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lb" type="Probability" use="optional" default="0.0"/>
		<xs:attribute name="ub" type="Probability" use="optional" default="1.0"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointConstraint">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SoftConstraintsJointConstraint">
				<xs:attribute name="lb" type="Probability" use="optional" default="0.0"/>
				<xs:attribute name="ub" type="Probability" use="optional" default="1.0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleIntegratedChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>identifies the row to be penalized</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointUserDefinedPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SoftConstraintsJointConstraint">
				<xs:sequence>
					<xs:element name="customPenalty" type="SoftConstraintsUserDefinedPenaltyFunction"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SoftConstraints">
		<xs:sequence>
			<xs:element name="softCon" type="SoftConstraintsPenaltiesRow" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfCon</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSoftCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MultilevelAndStochasticProgramming">
		<xs:choice>
			<xs:sequence>
				<xs:element name="levelsOrTimeStages" type="TimeStages" minOccurs="0"/>
				<xs:element name="stochasticElements" type="StochasticElements" minOccurs="0"/>
				<xs:choice>
					<xs:element name="implicitTreeData" type="ImplicitTree" minOccurs="0"/>
					<xs:element name="scenarioData" type="ScenarioTree" minOccurs="0"/>
				</xs:choice>
			</xs:sequence>
			<xs:element name="nodalTree" type="NodalTree" minOccurs="0"/>
		</xs:choice>
	</xs:complexType>
	<xs:simpleType name="RefreshPointEnum">
		<xs:restriction base="xs:string">
			<xs:annotation>
				<xs:documentation>experiment</xs:documentation>
			</xs:annotation>
			<xs:enumeration value="onSystemStart"/>
			<xs:enumeration value="onServiceStart"/>
			<xs:enumeration value="onJobStart"/>
			<xs:enumeration value="onOptimizationStart"/>
			<xs:enumeration value="onInputChange"/>
			<xs:enumeration value="always"/>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
